diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/cli/next-dev.js /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/cli/next-dev.js
--- a/packages/next/dist/cli/next-dev.js	2025-09-03 22:20:46.000000000 -0700
+++ b/packages/next/dist/cli/next-dev.js	2025-09-03 22:22:15.000000000 -0700
@@ -217,19 +217,25 @@
                 const totalMem = _os.default.totalmem();
                 const totalMemInMB = Math.floor(totalMem / 1024 / 1024);
                 maxOldSpaceSize = Math.floor(totalMemInMB * 0.5).toString();
-                nodeOptions['max-old-space-size'] = maxOldSpaceSize;
+                nodeOptions['max-old-space-size'] = [
+                    maxOldSpaceSize
+                ];
                 // Ensure the max_old_space_size is not also set.
                 delete nodeOptions['max_old_space_size'];
             }
             if (options.disableSourceMaps) {
                 delete nodeOptions['enable-source-maps'];
             } else {
-                nodeOptions['enable-source-maps'] = true;
+                nodeOptions['enable-source-maps'] = [
+                    true
+                ];
             }
             if (nodeDebugType) {
                 const address = (0, _utils.getParsedDebugAddress)();
                 address.port = address.port + 1;
-                nodeOptions[nodeDebugType] = (0, _utils.formatDebugAddress)(address);
+                nodeOptions[nodeDebugType] = [
+                    (0, _utils.formatDebugAddress)(address)
+                ];
             }
             child = (0, _child_process.fork)(startServerPath, {
                 stdio: 'inherit',
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/cli/next-dev.js.map /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/cli/next-dev.js.map
--- a/packages/next/dist/cli/next-dev.js.map	2025-09-03 22:20:46.000000000 -0700
+++ b/packages/next/dist/cli/next-dev.js.map	2025-09-03 22:22:15.000000000 -0700
@@ -1 +1 @@
-{"version":3,"sources":["../../src/cli/next-dev.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport '../server/lib/cpu-profile'\nimport type { StartServerOptions } from '../server/lib/start-server'\nimport {\n  RESTART_EXIT_CODE,\n  getNodeDebugType,\n  getParsedDebugAddress,\n  getMaxOldSpaceSize,\n  getParsedNodeOptionsWithoutInspect,\n  printAndExit,\n  formatNodeOptions,\n  formatDebugAddress,\n} from '../server/lib/utils'\nimport * as Log from '../build/output/log'\nimport { getProjectDir } from '../lib/get-project-dir'\nimport { PHASE_DEVELOPMENT_SERVER } from '../shared/lib/constants'\nimport path from 'path'\nimport type { NextConfigComplete } from '../server/config-shared'\nimport { traceGlobals } from '../trace/shared'\nimport { Telemetry } from '../telemetry/storage'\nimport loadConfig from '../server/config'\nimport { findPagesDir } from '../lib/find-pages-dir'\nimport { fileExists, FileType } from '../lib/file-exists'\nimport { getNpxCommand } from '../lib/helpers/get-npx-command'\nimport { createSelfSignedCertificate } from '../lib/mkcert'\nimport type { SelfSignedCertificate } from '../lib/mkcert'\nimport uploadTrace from '../trace/upload-trace'\nimport { initialEnv } from '@next/env'\nimport { fork } from 'child_process'\nimport type { ChildProcess } from 'child_process'\nimport {\n  getReservedPortExplanation,\n  isPortIsReserved,\n} from '../lib/helpers/get-reserved-port'\nimport os from 'os'\nimport { once } from 'node:events'\nimport { clearTimeout } from 'timers'\nimport { flushAllTraces, trace } from '../trace'\nimport { traceId } from '../trace/shared'\n\nexport type NextDevOptions = {\n  disableSourceMaps: boolean\n  turbo?: boolean\n  turbopack?: boolean\n  port: number\n  hostname?: string\n  experimentalHttps?: boolean\n  experimentalHttpsKey?: string\n  experimentalHttpsCert?: string\n  experimentalHttpsCa?: string\n  experimentalUploadTrace?: string\n}\n\ntype PortSource = 'cli' | 'default' | 'env'\n\nlet dir: string\nlet child: undefined | ChildProcess\n// The config in next-dev is only used to access config.distDir for telemetry and trace.\nlet config: NextConfigComplete\nlet isTurboSession = false\nlet traceUploadUrl: string\nlet sessionStopHandled = false\nlet sessionStarted = Date.now()\nlet sessionSpan = trace('next-dev')\n\n// How long should we wait for the child to cleanly exit after sending\n// SIGINT/SIGTERM to the child process before sending SIGKILL?\nconst CHILD_EXIT_TIMEOUT_MS = parseInt(\n  process.env.NEXT_EXIT_TIMEOUT_MS ?? '100',\n  10\n)\n\nconst handleSessionStop = async (signal: NodeJS.Signals | number | null) => {\n  if (signal != null && child?.pid) child.kill(signal)\n  if (sessionStopHandled) return\n  sessionStopHandled = true\n\n  if (\n    signal != null &&\n    child?.pid &&\n    child.exitCode === null &&\n    child.signalCode === null\n  ) {\n    let exitTimeout = setTimeout(() => {\n      child?.kill('SIGKILL')\n    }, CHILD_EXIT_TIMEOUT_MS)\n    await once(child, 'exit').catch(() => {})\n    clearTimeout(exitTimeout)\n  }\n\n  sessionSpan.stop()\n  await flushAllTraces({ end: true })\n\n  try {\n    const { eventCliSessionStopped } =\n      require('../telemetry/events/session-stopped') as typeof import('../telemetry/events/session-stopped')\n\n    let pagesDir: boolean = !!traceGlobals.get('pagesDir')\n    let appDir: boolean = !!traceGlobals.get('appDir')\n\n    if (\n      typeof traceGlobals.get('pagesDir') === 'undefined' ||\n      typeof traceGlobals.get('appDir') === 'undefined'\n    ) {\n      const pagesResult = findPagesDir(dir)\n      appDir = !!pagesResult.appDir\n      pagesDir = !!pagesResult.pagesDir\n    }\n\n    config =\n      config ||\n      (await loadConfig(PHASE_DEVELOPMENT_SERVER, dir, { silent: true }))\n\n    let telemetry =\n      (traceGlobals.get('telemetry') as InstanceType<\n        typeof import('../telemetry/storage').Telemetry\n      >) ||\n      new Telemetry({\n        distDir: path.join(dir, config.distDir),\n      })\n\n    telemetry.record(\n      eventCliSessionStopped({\n        cliCommand: 'dev',\n        turboFlag: isTurboSession,\n        durationMilliseconds: Date.now() - sessionStarted,\n        pagesDir,\n        appDir,\n      }),\n      true\n    )\n    telemetry.flushDetached('dev', dir)\n  } catch (_) {\n    // errors here aren't actionable so don't add\n    // noise to the output\n  }\n\n  if (traceUploadUrl) {\n    uploadTrace({\n      traceUploadUrl,\n      mode: 'dev',\n      projectDir: dir,\n      distDir: config.distDir,\n      isTurboSession,\n    })\n  }\n\n  // ensure we re-enable the terminal cursor before exiting\n  // the program, or the cursor could remain hidden\n  process.stdout.write('\\x1B[?25h')\n  process.stdout.write('\\n')\n  process.exit(0)\n}\n\nprocess.on('SIGINT', () => handleSessionStop('SIGINT'))\nprocess.on('SIGTERM', () => handleSessionStop('SIGTERM'))\n\n// exit event must be synchronous\nprocess.on('exit', () => child?.kill('SIGKILL'))\n\nconst nextDev = async (\n  options: NextDevOptions,\n  portSource: PortSource,\n  directory?: string\n) => {\n  const isTurbopack = Boolean(\n    options.turbo || options.turbopack || process.env.IS_TURBOPACK_TEST\n  )\n  if (isTurbopack) {\n    process.env.TURBOPACK = '1'\n  }\n\n  isTurboSession = isTurbopack\n\n  dir = getProjectDir(process.env.NEXT_PRIVATE_DEV_DIR || directory)\n\n  // Check if pages dir exists and warn if not\n  if (!(await fileExists(dir, FileType.Directory))) {\n    printAndExit(`> No such directory exists as the project root: ${dir}`)\n  }\n\n  async function preflight(skipOnReboot: boolean) {\n    const { getPackageVersion, getDependencies } = (await Promise.resolve(\n      require('../lib/get-package-version') as typeof import('../lib/get-package-version')\n    )) as typeof import('../lib/get-package-version')\n\n    const [sassVersion, nodeSassVersion] = await Promise.all([\n      getPackageVersion({ cwd: dir, name: 'sass' }),\n      getPackageVersion({ cwd: dir, name: 'node-sass' }),\n    ])\n    if (sassVersion && nodeSassVersion) {\n      Log.warn(\n        'Your project has both `sass` and `node-sass` installed as dependencies, but should only use one or the other. ' +\n          'Please remove the `node-sass` dependency from your project. ' +\n          ' Read more: https://nextjs.org/docs/messages/duplicate-sass'\n      )\n    }\n\n    if (!skipOnReboot) {\n      const { dependencies, devDependencies } = await getDependencies({\n        cwd: dir,\n      })\n\n      // Warn if @next/font is installed as a dependency. Ignore `workspace:*` to not warn in the Next.js monorepo.\n      if (\n        dependencies['@next/font'] ||\n        (devDependencies['@next/font'] &&\n          devDependencies['@next/font'] !== 'workspace:*')\n      ) {\n        const command = getNpxCommand(dir)\n        Log.warn(\n          'Your project has `@next/font` installed as a dependency, please use the built-in `next/font` instead. ' +\n            'The `@next/font` package will be removed in Next.js 14. ' +\n            `You can migrate by running \\`${command} @next/codemod@latest built-in-next-font .\\`. Read more: https://nextjs.org/docs/messages/built-in-next-font`\n        )\n      }\n    }\n  }\n\n  let port = options.port\n\n  if (isPortIsReserved(port)) {\n    printAndExit(getReservedPortExplanation(port), 1)\n  }\n\n  // If neither --port nor PORT were specified, it's okay to retry new ports.\n  const allowRetry = portSource === 'default'\n\n  // We do not set a default host value here to prevent breaking\n  // some set-ups that rely on listening on other interfaces\n  const host = options.hostname\n\n  if (\n    options.experimentalUploadTrace &&\n    !process.env.NEXT_TRACE_UPLOAD_DISABLED\n  ) {\n    traceUploadUrl = options.experimentalUploadTrace\n  }\n\n  const devServerOptions: StartServerOptions = {\n    dir,\n    port,\n    allowRetry,\n    isDev: true,\n    hostname: host,\n  }\n\n  const startServerPath = require.resolve('../server/lib/start-server')\n\n  async function startServer(startServerOptions: StartServerOptions) {\n    return new Promise<void>((resolve) => {\n      let resolved = false\n      const defaultEnv = (initialEnv || process.env) as typeof process.env\n\n      const nodeOptions = getParsedNodeOptionsWithoutInspect()\n      const nodeDebugType = getNodeDebugType()\n\n      let maxOldSpaceSize: string | number | undefined = getMaxOldSpaceSize()\n      if (!maxOldSpaceSize && !process.env.NEXT_DISABLE_MEM_OVERRIDE) {\n        const totalMem = os.totalmem()\n        const totalMemInMB = Math.floor(totalMem / 1024 / 1024)\n        maxOldSpaceSize = Math.floor(totalMemInMB * 0.5).toString()\n\n        nodeOptions['max-old-space-size'] = maxOldSpaceSize\n\n        // Ensure the max_old_space_size is not also set.\n        delete nodeOptions['max_old_space_size']\n      }\n\n      if (options.disableSourceMaps) {\n        delete nodeOptions['enable-source-maps']\n      } else {\n        nodeOptions['enable-source-maps'] = true\n      }\n\n      if (nodeDebugType) {\n        const address = getParsedDebugAddress()\n        address.port = address.port + 1\n        nodeOptions[nodeDebugType] = formatDebugAddress(address)\n      }\n\n      child = fork(startServerPath, {\n        stdio: 'inherit',\n        env: {\n          ...defaultEnv,\n          ...(isTurbopack ? { TURBOPACK: '1' } : undefined),\n          NEXT_PRIVATE_WORKER: '1',\n          NEXT_PRIVATE_TRACE_ID: traceId,\n          NODE_EXTRA_CA_CERTS: startServerOptions.selfSignedCertificate\n            ? startServerOptions.selfSignedCertificate.rootCA\n            : defaultEnv.NODE_EXTRA_CA_CERTS,\n          NODE_OPTIONS: formatNodeOptions(nodeOptions),\n          // There is a node.js bug on MacOS which causes closing file watchers to be really slow.\n          // This limits the number of watchers to mitigate the issue.\n          // https://github.com/nodejs/node/issues/29949\n          WATCHPACK_WATCHER_LIMIT:\n            os.platform() === 'darwin' ? '20' : undefined,\n        },\n      })\n\n      child.on('message', (msg: any) => {\n        if (msg && typeof msg === 'object') {\n          if (msg.nextWorkerReady) {\n            child?.send({ nextWorkerOptions: startServerOptions })\n          } else if (msg.nextServerReady && !resolved) {\n            if (msg.port) {\n              // Store the used port in case a random one was selected, so that\n              // it can be re-used on automatic dev server restarts.\n              port = parseInt(msg.port, 10)\n            }\n\n            resolved = true\n            resolve()\n          }\n        }\n      })\n\n      child.on('exit', async (code, signal) => {\n        if (sessionStopHandled || signal) {\n          return\n        }\n        if (code === RESTART_EXIT_CODE) {\n          // Starting the dev server will overwrite the `.next/trace` file, so we\n          // must upload the existing contents before restarting the server to\n          // preserve the metrics.\n          if (traceUploadUrl) {\n            // Postpone loading next config when we need to get\n            //  config.distDir for upload trace.\n            config =\n              config ||\n              (await loadConfig(PHASE_DEVELOPMENT_SERVER, dir, {\n                silent: true,\n              }))\n            uploadTrace({\n              traceUploadUrl,\n              mode: 'dev',\n              projectDir: dir,\n              distDir: config.distDir,\n              isTurboSession,\n              sync: true,\n            })\n          }\n\n          return startServer({ ...startServerOptions, port })\n        }\n        // Call handler (e.g. upload telemetry). Don't try to send a signal to\n        // the child, as it has already exited.\n        await handleSessionStop(/* signal */ null)\n      })\n    })\n  }\n\n  const runDevServer = async (reboot: boolean) => {\n    try {\n      if (!!options.experimentalHttps) {\n        Log.warn(\n          'Self-signed certificates are currently an experimental feature, use with caution.'\n        )\n\n        let certificate: SelfSignedCertificate | undefined\n\n        const key = options.experimentalHttpsKey\n        const cert = options.experimentalHttpsCert\n        const rootCA = options.experimentalHttpsCa\n\n        if (key && cert) {\n          certificate = {\n            key: path.resolve(key),\n            cert: path.resolve(cert),\n            rootCA: rootCA ? path.resolve(rootCA) : undefined,\n          }\n        } else {\n          certificate = await createSelfSignedCertificate(host)\n        }\n\n        await startServer({\n          ...devServerOptions,\n          selfSignedCertificate: certificate,\n        })\n      } else {\n        await startServer(devServerOptions)\n      }\n\n      await preflight(reboot)\n    } catch (err) {\n      console.error(err)\n      process.exit(1)\n    }\n  }\n\n  await runDevServer(false)\n}\n\nexport { nextDev }\n"],"names":["nextDev","dir","child","config","isTurboSession","traceUploadUrl","sessionStopHandled","sessionStarted","Date","now","sessionSpan","trace","CHILD_EXIT_TIMEOUT_MS","parseInt","process","env","NEXT_EXIT_TIMEOUT_MS","handleSessionStop","signal","pid","kill","exitCode","signalCode","exitTimeout","setTimeout","once","catch","clearTimeout","stop","flushAllTraces","end","eventCliSessionStopped","require","pagesDir","traceGlobals","get","appDir","pagesResult","findPagesDir","loadConfig","PHASE_DEVELOPMENT_SERVER","silent","telemetry","Telemetry","distDir","path","join","record","cliCommand","turboFlag","durationMilliseconds","flushDetached","_","uploadTrace","mode","projectDir","stdout","write","exit","on","options","portSource","directory","isTurbopack","Boolean","turbo","turbopack","IS_TURBOPACK_TEST","TURBOPACK","getProjectDir","NEXT_PRIVATE_DEV_DIR","fileExists","FileType","Directory","printAndExit","preflight","skipOnReboot","getPackageVersion","getDependencies","Promise","resolve","sassVersion","nodeSassVersion","all","cwd","name","Log","warn","dependencies","devDependencies","command","getNpxCommand","port","isPortIsReserved","getReservedPortExplanation","allowRetry","host","hostname","experimentalUploadTrace","NEXT_TRACE_UPLOAD_DISABLED","devServerOptions","isDev","startServerPath","startServer","startServerOptions","resolved","defaultEnv","initialEnv","nodeOptions","getParsedNodeOptionsWithoutInspect","nodeDebugType","getNodeDebugType","maxOldSpaceSize","getMaxOldSpaceSize","NEXT_DISABLE_MEM_OVERRIDE","totalMem","os","totalmem","totalMemInMB","Math","floor","toString","disableSourceMaps","address","getParsedDebugAddress","formatDebugAddress","fork","stdio","undefined","NEXT_PRIVATE_WORKER","NEXT_PRIVATE_TRACE_ID","traceId","NODE_EXTRA_CA_CERTS","selfSignedCertificate","rootCA","NODE_OPTIONS","formatNodeOptions","WATCHPACK_WATCHER_LIMIT","platform","msg","nextWorkerReady","send","nextWorkerOptions","nextServerReady","code","RESTART_EXIT_CODE","sync","runDevServer","reboot","experimentalHttps","certificate","key","experimentalHttpsKey","cert","experimentalHttpsCert","experimentalHttpsCa","createSelfSignedCertificate","err","console","error"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
+{"version":3,"sources":["../../src/cli/next-dev.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport '../server/lib/cpu-profile'\nimport type { StartServerOptions } from '../server/lib/start-server'\nimport {\n  RESTART_EXIT_CODE,\n  getNodeDebugType,\n  getParsedDebugAddress,\n  getMaxOldSpaceSize,\n  getParsedNodeOptionsWithoutInspect,\n  printAndExit,\n  formatNodeOptions,\n  formatDebugAddress,\n} from '../server/lib/utils'\nimport * as Log from '../build/output/log'\nimport { getProjectDir } from '../lib/get-project-dir'\nimport { PHASE_DEVELOPMENT_SERVER } from '../shared/lib/constants'\nimport path from 'path'\nimport type { NextConfigComplete } from '../server/config-shared'\nimport { traceGlobals } from '../trace/shared'\nimport { Telemetry } from '../telemetry/storage'\nimport loadConfig from '../server/config'\nimport { findPagesDir } from '../lib/find-pages-dir'\nimport { fileExists, FileType } from '../lib/file-exists'\nimport { getNpxCommand } from '../lib/helpers/get-npx-command'\nimport { createSelfSignedCertificate } from '../lib/mkcert'\nimport type { SelfSignedCertificate } from '../lib/mkcert'\nimport uploadTrace from '../trace/upload-trace'\nimport { initialEnv } from '@next/env'\nimport { fork } from 'child_process'\nimport type { ChildProcess } from 'child_process'\nimport {\n  getReservedPortExplanation,\n  isPortIsReserved,\n} from '../lib/helpers/get-reserved-port'\nimport os from 'os'\nimport { once } from 'node:events'\nimport { clearTimeout } from 'timers'\nimport { flushAllTraces, trace } from '../trace'\nimport { traceId } from '../trace/shared'\n\nexport type NextDevOptions = {\n  disableSourceMaps: boolean\n  turbo?: boolean\n  turbopack?: boolean\n  port: number\n  hostname?: string\n  experimentalHttps?: boolean\n  experimentalHttpsKey?: string\n  experimentalHttpsCert?: string\n  experimentalHttpsCa?: string\n  experimentalUploadTrace?: string\n}\n\ntype PortSource = 'cli' | 'default' | 'env'\n\nlet dir: string\nlet child: undefined | ChildProcess\n// The config in next-dev is only used to access config.distDir for telemetry and trace.\nlet config: NextConfigComplete\nlet isTurboSession = false\nlet traceUploadUrl: string\nlet sessionStopHandled = false\nlet sessionStarted = Date.now()\nlet sessionSpan = trace('next-dev')\n\n// How long should we wait for the child to cleanly exit after sending\n// SIGINT/SIGTERM to the child process before sending SIGKILL?\nconst CHILD_EXIT_TIMEOUT_MS = parseInt(\n  process.env.NEXT_EXIT_TIMEOUT_MS ?? '100',\n  10\n)\n\nconst handleSessionStop = async (signal: NodeJS.Signals | number | null) => {\n  if (signal != null && child?.pid) child.kill(signal)\n  if (sessionStopHandled) return\n  sessionStopHandled = true\n\n  if (\n    signal != null &&\n    child?.pid &&\n    child.exitCode === null &&\n    child.signalCode === null\n  ) {\n    let exitTimeout = setTimeout(() => {\n      child?.kill('SIGKILL')\n    }, CHILD_EXIT_TIMEOUT_MS)\n    await once(child, 'exit').catch(() => {})\n    clearTimeout(exitTimeout)\n  }\n\n  sessionSpan.stop()\n  await flushAllTraces({ end: true })\n\n  try {\n    const { eventCliSessionStopped } =\n      require('../telemetry/events/session-stopped') as typeof import('../telemetry/events/session-stopped')\n\n    let pagesDir: boolean = !!traceGlobals.get('pagesDir')\n    let appDir: boolean = !!traceGlobals.get('appDir')\n\n    if (\n      typeof traceGlobals.get('pagesDir') === 'undefined' ||\n      typeof traceGlobals.get('appDir') === 'undefined'\n    ) {\n      const pagesResult = findPagesDir(dir)\n      appDir = !!pagesResult.appDir\n      pagesDir = !!pagesResult.pagesDir\n    }\n\n    config =\n      config ||\n      (await loadConfig(PHASE_DEVELOPMENT_SERVER, dir, { silent: true }))\n\n    let telemetry =\n      (traceGlobals.get('telemetry') as InstanceType<\n        typeof import('../telemetry/storage').Telemetry\n      >) ||\n      new Telemetry({\n        distDir: path.join(dir, config.distDir),\n      })\n\n    telemetry.record(\n      eventCliSessionStopped({\n        cliCommand: 'dev',\n        turboFlag: isTurboSession,\n        durationMilliseconds: Date.now() - sessionStarted,\n        pagesDir,\n        appDir,\n      }),\n      true\n    )\n    telemetry.flushDetached('dev', dir)\n  } catch (_) {\n    // errors here aren't actionable so don't add\n    // noise to the output\n  }\n\n  if (traceUploadUrl) {\n    uploadTrace({\n      traceUploadUrl,\n      mode: 'dev',\n      projectDir: dir,\n      distDir: config.distDir,\n      isTurboSession,\n    })\n  }\n\n  // ensure we re-enable the terminal cursor before exiting\n  // the program, or the cursor could remain hidden\n  process.stdout.write('\\x1B[?25h')\n  process.stdout.write('\\n')\n  process.exit(0)\n}\n\nprocess.on('SIGINT', () => handleSessionStop('SIGINT'))\nprocess.on('SIGTERM', () => handleSessionStop('SIGTERM'))\n\n// exit event must be synchronous\nprocess.on('exit', () => child?.kill('SIGKILL'))\n\nconst nextDev = async (\n  options: NextDevOptions,\n  portSource: PortSource,\n  directory?: string\n) => {\n  const isTurbopack = Boolean(\n    options.turbo || options.turbopack || process.env.IS_TURBOPACK_TEST\n  )\n  if (isTurbopack) {\n    process.env.TURBOPACK = '1'\n  }\n\n  isTurboSession = isTurbopack\n\n  dir = getProjectDir(process.env.NEXT_PRIVATE_DEV_DIR || directory)\n\n  // Check if pages dir exists and warn if not\n  if (!(await fileExists(dir, FileType.Directory))) {\n    printAndExit(`> No such directory exists as the project root: ${dir}`)\n  }\n\n  async function preflight(skipOnReboot: boolean) {\n    const { getPackageVersion, getDependencies } = (await Promise.resolve(\n      require('../lib/get-package-version') as typeof import('../lib/get-package-version')\n    )) as typeof import('../lib/get-package-version')\n\n    const [sassVersion, nodeSassVersion] = await Promise.all([\n      getPackageVersion({ cwd: dir, name: 'sass' }),\n      getPackageVersion({ cwd: dir, name: 'node-sass' }),\n    ])\n    if (sassVersion && nodeSassVersion) {\n      Log.warn(\n        'Your project has both `sass` and `node-sass` installed as dependencies, but should only use one or the other. ' +\n          'Please remove the `node-sass` dependency from your project. ' +\n          ' Read more: https://nextjs.org/docs/messages/duplicate-sass'\n      )\n    }\n\n    if (!skipOnReboot) {\n      const { dependencies, devDependencies } = await getDependencies({\n        cwd: dir,\n      })\n\n      // Warn if @next/font is installed as a dependency. Ignore `workspace:*` to not warn in the Next.js monorepo.\n      if (\n        dependencies['@next/font'] ||\n        (devDependencies['@next/font'] &&\n          devDependencies['@next/font'] !== 'workspace:*')\n      ) {\n        const command = getNpxCommand(dir)\n        Log.warn(\n          'Your project has `@next/font` installed as a dependency, please use the built-in `next/font` instead. ' +\n            'The `@next/font` package will be removed in Next.js 14. ' +\n            `You can migrate by running \\`${command} @next/codemod@latest built-in-next-font .\\`. Read more: https://nextjs.org/docs/messages/built-in-next-font`\n        )\n      }\n    }\n  }\n\n  let port = options.port\n\n  if (isPortIsReserved(port)) {\n    printAndExit(getReservedPortExplanation(port), 1)\n  }\n\n  // If neither --port nor PORT were specified, it's okay to retry new ports.\n  const allowRetry = portSource === 'default'\n\n  // We do not set a default host value here to prevent breaking\n  // some set-ups that rely on listening on other interfaces\n  const host = options.hostname\n\n  if (\n    options.experimentalUploadTrace &&\n    !process.env.NEXT_TRACE_UPLOAD_DISABLED\n  ) {\n    traceUploadUrl = options.experimentalUploadTrace\n  }\n\n  const devServerOptions: StartServerOptions = {\n    dir,\n    port,\n    allowRetry,\n    isDev: true,\n    hostname: host,\n  }\n\n  const startServerPath = require.resolve('../server/lib/start-server')\n\n  async function startServer(startServerOptions: StartServerOptions) {\n    return new Promise<void>((resolve) => {\n      let resolved = false\n      const defaultEnv = (initialEnv || process.env) as typeof process.env\n\n      const nodeOptions = getParsedNodeOptionsWithoutInspect()\n      const nodeDebugType = getNodeDebugType()\n\n      let maxOldSpaceSize: string | number | undefined = getMaxOldSpaceSize()\n      if (!maxOldSpaceSize && !process.env.NEXT_DISABLE_MEM_OVERRIDE) {\n        const totalMem = os.totalmem()\n        const totalMemInMB = Math.floor(totalMem / 1024 / 1024)\n        maxOldSpaceSize = Math.floor(totalMemInMB * 0.5).toString()\n\n        nodeOptions['max-old-space-size'] = [maxOldSpaceSize]\n\n        // Ensure the max_old_space_size is not also set.\n        delete nodeOptions['max_old_space_size']\n      }\n\n      if (options.disableSourceMaps) {\n        delete nodeOptions['enable-source-maps']\n      } else {\n        nodeOptions['enable-source-maps'] = [true]\n      }\n\n      if (nodeDebugType) {\n        const address = getParsedDebugAddress()\n        address.port = address.port + 1\n        nodeOptions[nodeDebugType] = [formatDebugAddress(address)]\n      }\n\n      child = fork(startServerPath, {\n        stdio: 'inherit',\n        env: {\n          ...defaultEnv,\n          ...(isTurbopack ? { TURBOPACK: '1' } : undefined),\n          NEXT_PRIVATE_WORKER: '1',\n          NEXT_PRIVATE_TRACE_ID: traceId,\n          NODE_EXTRA_CA_CERTS: startServerOptions.selfSignedCertificate\n            ? startServerOptions.selfSignedCertificate.rootCA\n            : defaultEnv.NODE_EXTRA_CA_CERTS,\n          NODE_OPTIONS: formatNodeOptions(nodeOptions),\n          // There is a node.js bug on MacOS which causes closing file watchers to be really slow.\n          // This limits the number of watchers to mitigate the issue.\n          // https://github.com/nodejs/node/issues/29949\n          WATCHPACK_WATCHER_LIMIT:\n            os.platform() === 'darwin' ? '20' : undefined,\n        },\n      })\n\n      child.on('message', (msg: any) => {\n        if (msg && typeof msg === 'object') {\n          if (msg.nextWorkerReady) {\n            child?.send({ nextWorkerOptions: startServerOptions })\n          } else if (msg.nextServerReady && !resolved) {\n            if (msg.port) {\n              // Store the used port in case a random one was selected, so that\n              // it can be re-used on automatic dev server restarts.\n              port = parseInt(msg.port, 10)\n            }\n\n            resolved = true\n            resolve()\n          }\n        }\n      })\n\n      child.on('exit', async (code, signal) => {\n        if (sessionStopHandled || signal) {\n          return\n        }\n        if (code === RESTART_EXIT_CODE) {\n          // Starting the dev server will overwrite the `.next/trace` file, so we\n          // must upload the existing contents before restarting the server to\n          // preserve the metrics.\n          if (traceUploadUrl) {\n            // Postpone loading next config when we need to get\n            //  config.distDir for upload trace.\n            config =\n              config ||\n              (await loadConfig(PHASE_DEVELOPMENT_SERVER, dir, {\n                silent: true,\n              }))\n            uploadTrace({\n              traceUploadUrl,\n              mode: 'dev',\n              projectDir: dir,\n              distDir: config.distDir,\n              isTurboSession,\n              sync: true,\n            })\n          }\n\n          return startServer({ ...startServerOptions, port })\n        }\n        // Call handler (e.g. upload telemetry). Don't try to send a signal to\n        // the child, as it has already exited.\n        await handleSessionStop(/* signal */ null)\n      })\n    })\n  }\n\n  const runDevServer = async (reboot: boolean) => {\n    try {\n      if (!!options.experimentalHttps) {\n        Log.warn(\n          'Self-signed certificates are currently an experimental feature, use with caution.'\n        )\n\n        let certificate: SelfSignedCertificate | undefined\n\n        const key = options.experimentalHttpsKey\n        const cert = options.experimentalHttpsCert\n        const rootCA = options.experimentalHttpsCa\n\n        if (key && cert) {\n          certificate = {\n            key: path.resolve(key),\n            cert: path.resolve(cert),\n            rootCA: rootCA ? path.resolve(rootCA) : undefined,\n          }\n        } else {\n          certificate = await createSelfSignedCertificate(host)\n        }\n\n        await startServer({\n          ...devServerOptions,\n          selfSignedCertificate: certificate,\n        })\n      } else {\n        await startServer(devServerOptions)\n      }\n\n      await preflight(reboot)\n    } catch (err) {\n      console.error(err)\n      process.exit(1)\n    }\n  }\n\n  await runDevServer(false)\n}\n\nexport { nextDev }\n"],"names":["nextDev","dir","child","config","isTurboSession","traceUploadUrl","sessionStopHandled","sessionStarted","Date","now","sessionSpan","trace","CHILD_EXIT_TIMEOUT_MS","parseInt","process","env","NEXT_EXIT_TIMEOUT_MS","handleSessionStop","signal","pid","kill","exitCode","signalCode","exitTimeout","setTimeout","once","catch","clearTimeout","stop","flushAllTraces","end","eventCliSessionStopped","require","pagesDir","traceGlobals","get","appDir","pagesResult","findPagesDir","loadConfig","PHASE_DEVELOPMENT_SERVER","silent","telemetry","Telemetry","distDir","path","join","record","cliCommand","turboFlag","durationMilliseconds","flushDetached","_","uploadTrace","mode","projectDir","stdout","write","exit","on","options","portSource","directory","isTurbopack","Boolean","turbo","turbopack","IS_TURBOPACK_TEST","TURBOPACK","getProjectDir","NEXT_PRIVATE_DEV_DIR","fileExists","FileType","Directory","printAndExit","preflight","skipOnReboot","getPackageVersion","getDependencies","Promise","resolve","sassVersion","nodeSassVersion","all","cwd","name","Log","warn","dependencies","devDependencies","command","getNpxCommand","port","isPortIsReserved","getReservedPortExplanation","allowRetry","host","hostname","experimentalUploadTrace","NEXT_TRACE_UPLOAD_DISABLED","devServerOptions","isDev","startServerPath","startServer","startServerOptions","resolved","defaultEnv","initialEnv","nodeOptions","getParsedNodeOptionsWithoutInspect","nodeDebugType","getNodeDebugType","maxOldSpaceSize","getMaxOldSpaceSize","NEXT_DISABLE_MEM_OVERRIDE","totalMem","os","totalmem","totalMemInMB","Math","floor","toString","disableSourceMaps","address","getParsedDebugAddress","formatDebugAddress","fork","stdio","undefined","NEXT_PRIVATE_WORKER","NEXT_PRIVATE_TRACE_ID","traceId","NODE_EXTRA_CA_CERTS","selfSignedCertificate","rootCA","NODE_OPTIONS","formatNodeOptions","WATCHPACK_WATCHER_LIMIT","platform","msg","nextWorkerReady","send","nextWorkerOptions","nextServerReady","code","RESTART_EXIT_CODE","sync","runDevServer","reboot","experimentalHttps","certificate","key","experimentalHttpsKey","cert","experimentalHttpsCert","experimentalHttpsCa","createSelfSignedCertificate","err","console","error"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/esm/lib/worker.js /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/esm/lib/worker.js
--- a/packages/next/dist/esm/lib/worker.js	2025-09-03 22:20:44.000000000 -0700
+++ b/packages/next/dist/esm/lib/worker.js	2025-09-03 22:22:13.000000000 -0700
@@ -31,11 +31,15 @@
                 const address = getParsedDebugAddress();
                 address.port = address.port + // current process runs on `address.port`
                 1 + debuggerPortOffset;
-                nodeOptions[nodeDebugType] = formatDebugAddress(address);
+                nodeOptions[nodeDebugType] = [
+                    formatDebugAddress(address)
+                ];
             }
         }
         if (enableSourceMaps) {
-            nodeOptions['enable-source-maps'] = true;
+            nodeOptions['enable-source-maps'] = [
+                true
+            ];
         }
         if (isolatedMemory) {
             delete nodeOptions['max-old-space-size'];
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/esm/lib/worker.js.map /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/esm/lib/worker.js.map
--- a/packages/next/dist/esm/lib/worker.js.map	2025-09-03 22:20:44.000000000 -0700
+++ b/packages/next/dist/esm/lib/worker.js.map	2025-09-03 22:22:13.000000000 -0700
@@ -1 +1 @@
-{"version":3,"sources":["../../src/lib/worker.ts"],"sourcesContent":["import type { ChildProcess } from 'child_process'\nimport { Worker as JestWorker } from 'next/dist/compiled/jest-worker'\nimport { Transform } from 'stream'\nimport {\n  formatDebugAddress,\n  formatNodeOptions,\n  getNodeDebugType,\n  getParsedDebugAddress,\n  getParsedNodeOptionsWithoutInspect,\n} from '../server/lib/utils'\n\ntype FarmOptions = NonNullable<ConstructorParameters<typeof JestWorker>[1]>\n\nconst RESTARTED = Symbol('restarted')\n\nconst cleanupWorkers = (worker: JestWorker) => {\n  for (const curWorker of ((worker as any)._workerPool?._workers || []) as {\n    _child?: ChildProcess\n  }[]) {\n    curWorker._child?.kill('SIGINT')\n  }\n}\n\nexport function getNextBuildDebuggerPortOffset(_: {\n  kind: 'export-page'\n}): number {\n  // 0: export worker\n  return 0\n}\n\nexport class Worker {\n  private _worker: JestWorker | undefined\n\n  constructor(\n    workerPath: string,\n    options: Omit<FarmOptions, 'forkOptions'> & {\n      forkOptions?:\n        | (Omit<NonNullable<FarmOptions['forkOptions']>, 'env'> & {\n            env?: Partial<NodeJS.ProcessEnv> | undefined\n          })\n        | undefined\n      /**\n       * `-1` if not inspectable\n       */\n      debuggerPortOffset: number\n      enableSourceMaps?: boolean\n      /**\n       * True if `--max-old-space-size` should not be forwarded to the worker.\n       */\n      isolatedMemory: boolean\n      timeout?: number\n      onActivity?: () => void\n      onActivityAbort?: () => void\n      onRestart?: (method: string, args: any[], attempts: number) => void\n      logger?: Pick<typeof console, 'error' | 'info' | 'warn'>\n      exposedMethods: ReadonlyArray<string>\n      enableWorkerThreads?: boolean\n    }\n  ) {\n    let {\n      enableSourceMaps,\n      timeout,\n      onRestart,\n      logger = console,\n      debuggerPortOffset,\n      isolatedMemory,\n      ...farmOptions\n    } = options\n\n    let restartPromise: Promise<typeof RESTARTED>\n    let resolveRestartPromise: (arg: typeof RESTARTED) => void\n    let activeTasks = 0\n\n    this._worker = undefined\n\n    // ensure we end workers if they weren't before exit\n    process.on('exit', () => {\n      this.close()\n    })\n\n    const nodeOptions = getParsedNodeOptionsWithoutInspect()\n\n    if (debuggerPortOffset !== -1) {\n      const nodeDebugType = getNodeDebugType()\n      if (nodeDebugType) {\n        const address = getParsedDebugAddress()\n        address.port =\n          address.port +\n          // current process runs on `address.port`\n          1 +\n          debuggerPortOffset\n        nodeOptions[nodeDebugType] = formatDebugAddress(address)\n      }\n    }\n\n    if (enableSourceMaps) {\n      nodeOptions['enable-source-maps'] = true\n    }\n\n    if (isolatedMemory) {\n      delete nodeOptions['max-old-space-size']\n      delete nodeOptions['max_old_space_size']\n    }\n\n    const createWorker = () => {\n      this._worker = new JestWorker(workerPath, {\n        ...farmOptions,\n        forkOptions: {\n          ...farmOptions.forkOptions,\n          env: {\n            ...process.env,\n            ...((farmOptions.forkOptions?.env || {}) as any),\n            IS_NEXT_WORKER: 'true',\n            NODE_OPTIONS: formatNodeOptions(nodeOptions),\n          } as any,\n        },\n        maxRetries: 0,\n      }) as JestWorker\n      restartPromise = new Promise(\n        (resolve) => (resolveRestartPromise = resolve)\n      )\n\n      /**\n       * Jest Worker has two worker types, ChildProcessWorker (uses child_process) and NodeThreadWorker (uses worker_threads)\n       * Next.js uses ChildProcessWorker by default, but it can be switched to NodeThreadWorker with an experimental flag\n       *\n       * We only want to handle ChildProcessWorker's orphan process issue, so we access the private property \"_child\":\n       * https://github.com/facebook/jest/blob/b38d7d345a81d97d1dc3b68b8458b1837fbf19be/packages/jest-worker/src/workers/ChildProcessWorker.ts\n       *\n       * But this property is not available in NodeThreadWorker, so we need to check if we are using ChildProcessWorker\n       */\n      if (!farmOptions.enableWorkerThreads) {\n        for (const worker of ((this._worker as any)._workerPool?._workers ||\n          []) as {\n          _child?: ChildProcess\n        }[]) {\n          worker._child?.on('exit', (code, signal) => {\n            if ((code || (signal && signal !== 'SIGINT')) && this._worker) {\n              logger.error(\n                `Next.js build worker exited with code: ${code} and signal: ${signal}`\n              )\n\n              // if a child process doesn't exit gracefully, we want to bubble up the exit code to the parent process\n              process.exit(code ?? 1)\n            }\n          })\n\n          // if a child process emits a particular message, we track that as activity\n          // so the parent process can keep track of progress\n          worker._child?.on('message', ([, data]: [number, unknown]) => {\n            if (\n              data &&\n              typeof data === 'object' &&\n              'type' in data &&\n              data.type === 'activity'\n            ) {\n              onActivity()\n            }\n          })\n        }\n      }\n\n      let aborted = false\n      const onActivityAbort = () => {\n        if (!aborted) {\n          options.onActivityAbort?.()\n          aborted = true\n        }\n      }\n\n      // Listen to the worker's stdout and stderr, if there's any thing logged, abort the activity first\n      const abortActivityStreamOnLog = new Transform({\n        transform(_chunk, _encoding, callback) {\n          onActivityAbort()\n          callback()\n        },\n      })\n      // Stop the activity if there's any output from the worker\n      this._worker.getStdout().pipe(abortActivityStreamOnLog)\n      this._worker.getStderr().pipe(abortActivityStreamOnLog)\n\n      // Pipe the worker's stdout and stderr to the parent process\n      this._worker.getStdout().pipe(process.stdout)\n      this._worker.getStderr().pipe(process.stderr)\n    }\n    createWorker()\n\n    const onHanging = () => {\n      const worker = this._worker\n      if (!worker) return\n      const resolve = resolveRestartPromise\n      createWorker()\n      logger.warn(\n        `Sending SIGTERM signal to static worker due to timeout${\n          timeout ? ` of ${timeout / 1000} seconds` : ''\n        }. Subsequent errors may be a result of the worker exiting.`\n      )\n      worker.end().then(() => {\n        resolve(RESTARTED)\n      })\n    }\n\n    let hangingTimer: NodeJS.Timeout | false = false\n\n    const onActivity = () => {\n      if (hangingTimer) clearTimeout(hangingTimer)\n      if (options.onActivity) options.onActivity()\n\n      hangingTimer = activeTasks > 0 && setTimeout(onHanging, timeout)\n    }\n\n    for (const method of farmOptions.exposedMethods) {\n      if (method.startsWith('_')) continue\n      ;(this as any)[method] = timeout\n        ? // eslint-disable-next-line no-loop-func\n          async (...args: any[]) => {\n            activeTasks++\n            try {\n              let attempts = 0\n              for (;;) {\n                onActivity()\n                const result = await Promise.race([\n                  (this._worker as any)[method](...args),\n                  restartPromise,\n                ])\n                if (result !== RESTARTED) return result\n                if (onRestart) onRestart(method, args, ++attempts)\n              }\n            } finally {\n              activeTasks--\n              onActivity()\n            }\n          }\n        : (this._worker as any)[method].bind(this._worker)\n    }\n  }\n\n  end(): ReturnType<JestWorker['end']> {\n    const worker = this._worker\n    if (!worker) {\n      throw new Error('Farm is ended, no more calls can be done to it')\n    }\n    cleanupWorkers(worker)\n    this._worker = undefined\n    return worker.end()\n  }\n\n  /**\n   * Quietly end the worker if it exists\n   */\n  close(): void {\n    if (this._worker) {\n      cleanupWorkers(this._worker)\n      this._worker.end()\n    }\n  }\n}\n"],"names":["Worker","JestWorker","Transform","formatDebugAddress","formatNodeOptions","getNodeDebugType","getParsedDebugAddress","getParsedNodeOptionsWithoutInspect","RESTARTED","Symbol","cleanupWorkers","worker","curWorker","_workerPool","_workers","_child","kill","getNextBuildDebuggerPortOffset","_","constructor","workerPath","options","enableSourceMaps","timeout","onRestart","logger","console","debuggerPortOffset","isolatedMemory","farmOptions","restartPromise","resolveRestartPromise","activeTasks","_worker","undefined","process","on","close","nodeOptions","nodeDebugType","address","port","createWorker","forkOptions","env","IS_NEXT_WORKER","NODE_OPTIONS","maxRetries","Promise","resolve","enableWorkerThreads","code","signal","error","exit","data","type","onActivity","aborted","onActivityAbort","abortActivityStreamOnLog","transform","_chunk","_encoding","callback","getStdout","pipe","getStderr","stdout","stderr","onHanging","warn","end","then","hangingTimer","clearTimeout","setTimeout","method","exposedMethods","startsWith","args","attempts","result","race","bind","Error"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
+{"version":3,"sources":["../../src/lib/worker.ts"],"sourcesContent":["import type { ChildProcess } from 'child_process'\nimport { Worker as JestWorker } from 'next/dist/compiled/jest-worker'\nimport { Transform } from 'stream'\nimport {\n  formatDebugAddress,\n  formatNodeOptions,\n  getNodeDebugType,\n  getParsedDebugAddress,\n  getParsedNodeOptionsWithoutInspect,\n} from '../server/lib/utils'\n\ntype FarmOptions = NonNullable<ConstructorParameters<typeof JestWorker>[1]>\n\nconst RESTARTED = Symbol('restarted')\n\nconst cleanupWorkers = (worker: JestWorker) => {\n  for (const curWorker of ((worker as any)._workerPool?._workers || []) as {\n    _child?: ChildProcess\n  }[]) {\n    curWorker._child?.kill('SIGINT')\n  }\n}\n\nexport function getNextBuildDebuggerPortOffset(_: {\n  kind: 'export-page'\n}): number {\n  // 0: export worker\n  return 0\n}\n\nexport class Worker {\n  private _worker: JestWorker | undefined\n\n  constructor(\n    workerPath: string,\n    options: Omit<FarmOptions, 'forkOptions'> & {\n      forkOptions?:\n        | (Omit<NonNullable<FarmOptions['forkOptions']>, 'env'> & {\n            env?: Partial<NodeJS.ProcessEnv> | undefined\n          })\n        | undefined\n      /**\n       * `-1` if not inspectable\n       */\n      debuggerPortOffset: number\n      enableSourceMaps?: boolean\n      /**\n       * True if `--max-old-space-size` should not be forwarded to the worker.\n       */\n      isolatedMemory: boolean\n      timeout?: number\n      onActivity?: () => void\n      onActivityAbort?: () => void\n      onRestart?: (method: string, args: any[], attempts: number) => void\n      logger?: Pick<typeof console, 'error' | 'info' | 'warn'>\n      exposedMethods: ReadonlyArray<string>\n      enableWorkerThreads?: boolean\n    }\n  ) {\n    let {\n      enableSourceMaps,\n      timeout,\n      onRestart,\n      logger = console,\n      debuggerPortOffset,\n      isolatedMemory,\n      ...farmOptions\n    } = options\n\n    let restartPromise: Promise<typeof RESTARTED>\n    let resolveRestartPromise: (arg: typeof RESTARTED) => void\n    let activeTasks = 0\n\n    this._worker = undefined\n\n    // ensure we end workers if they weren't before exit\n    process.on('exit', () => {\n      this.close()\n    })\n\n    const nodeOptions = getParsedNodeOptionsWithoutInspect()\n\n    if (debuggerPortOffset !== -1) {\n      const nodeDebugType = getNodeDebugType()\n      if (nodeDebugType) {\n        const address = getParsedDebugAddress()\n        address.port =\n          address.port +\n          // current process runs on `address.port`\n          1 +\n          debuggerPortOffset\n        nodeOptions[nodeDebugType] = [formatDebugAddress(address)]\n      }\n    }\n\n    if (enableSourceMaps) {\n      nodeOptions['enable-source-maps'] = [true]\n    }\n\n    if (isolatedMemory) {\n      delete nodeOptions['max-old-space-size']\n      delete nodeOptions['max_old_space_size']\n    }\n\n    const createWorker = () => {\n      this._worker = new JestWorker(workerPath, {\n        ...farmOptions,\n        forkOptions: {\n          ...farmOptions.forkOptions,\n          env: {\n            ...process.env,\n            ...((farmOptions.forkOptions?.env || {}) as any),\n            IS_NEXT_WORKER: 'true',\n            NODE_OPTIONS: formatNodeOptions(nodeOptions),\n          } as any,\n        },\n        maxRetries: 0,\n      }) as JestWorker\n      restartPromise = new Promise(\n        (resolve) => (resolveRestartPromise = resolve)\n      )\n\n      /**\n       * Jest Worker has two worker types, ChildProcessWorker (uses child_process) and NodeThreadWorker (uses worker_threads)\n       * Next.js uses ChildProcessWorker by default, but it can be switched to NodeThreadWorker with an experimental flag\n       *\n       * We only want to handle ChildProcessWorker's orphan process issue, so we access the private property \"_child\":\n       * https://github.com/facebook/jest/blob/b38d7d345a81d97d1dc3b68b8458b1837fbf19be/packages/jest-worker/src/workers/ChildProcessWorker.ts\n       *\n       * But this property is not available in NodeThreadWorker, so we need to check if we are using ChildProcessWorker\n       */\n      if (!farmOptions.enableWorkerThreads) {\n        for (const worker of ((this._worker as any)._workerPool?._workers ||\n          []) as {\n          _child?: ChildProcess\n        }[]) {\n          worker._child?.on('exit', (code, signal) => {\n            if ((code || (signal && signal !== 'SIGINT')) && this._worker) {\n              logger.error(\n                `Next.js build worker exited with code: ${code} and signal: ${signal}`\n              )\n\n              // if a child process doesn't exit gracefully, we want to bubble up the exit code to the parent process\n              process.exit(code ?? 1)\n            }\n          })\n\n          // if a child process emits a particular message, we track that as activity\n          // so the parent process can keep track of progress\n          worker._child?.on('message', ([, data]: [number, unknown]) => {\n            if (\n              data &&\n              typeof data === 'object' &&\n              'type' in data &&\n              data.type === 'activity'\n            ) {\n              onActivity()\n            }\n          })\n        }\n      }\n\n      let aborted = false\n      const onActivityAbort = () => {\n        if (!aborted) {\n          options.onActivityAbort?.()\n          aborted = true\n        }\n      }\n\n      // Listen to the worker's stdout and stderr, if there's any thing logged, abort the activity first\n      const abortActivityStreamOnLog = new Transform({\n        transform(_chunk, _encoding, callback) {\n          onActivityAbort()\n          callback()\n        },\n      })\n      // Stop the activity if there's any output from the worker\n      this._worker.getStdout().pipe(abortActivityStreamOnLog)\n      this._worker.getStderr().pipe(abortActivityStreamOnLog)\n\n      // Pipe the worker's stdout and stderr to the parent process\n      this._worker.getStdout().pipe(process.stdout)\n      this._worker.getStderr().pipe(process.stderr)\n    }\n    createWorker()\n\n    const onHanging = () => {\n      const worker = this._worker\n      if (!worker) return\n      const resolve = resolveRestartPromise\n      createWorker()\n      logger.warn(\n        `Sending SIGTERM signal to static worker due to timeout${\n          timeout ? ` of ${timeout / 1000} seconds` : ''\n        }. Subsequent errors may be a result of the worker exiting.`\n      )\n      worker.end().then(() => {\n        resolve(RESTARTED)\n      })\n    }\n\n    let hangingTimer: NodeJS.Timeout | false = false\n\n    const onActivity = () => {\n      if (hangingTimer) clearTimeout(hangingTimer)\n      if (options.onActivity) options.onActivity()\n\n      hangingTimer = activeTasks > 0 && setTimeout(onHanging, timeout)\n    }\n\n    for (const method of farmOptions.exposedMethods) {\n      if (method.startsWith('_')) continue\n      ;(this as any)[method] = timeout\n        ? // eslint-disable-next-line no-loop-func\n          async (...args: any[]) => {\n            activeTasks++\n            try {\n              let attempts = 0\n              for (;;) {\n                onActivity()\n                const result = await Promise.race([\n                  (this._worker as any)[method](...args),\n                  restartPromise,\n                ])\n                if (result !== RESTARTED) return result\n                if (onRestart) onRestart(method, args, ++attempts)\n              }\n            } finally {\n              activeTasks--\n              onActivity()\n            }\n          }\n        : (this._worker as any)[method].bind(this._worker)\n    }\n  }\n\n  end(): ReturnType<JestWorker['end']> {\n    const worker = this._worker\n    if (!worker) {\n      throw new Error('Farm is ended, no more calls can be done to it')\n    }\n    cleanupWorkers(worker)\n    this._worker = undefined\n    return worker.end()\n  }\n\n  /**\n   * Quietly end the worker if it exists\n   */\n  close(): void {\n    if (this._worker) {\n      cleanupWorkers(this._worker)\n      this._worker.end()\n    }\n  }\n}\n"],"names":["Worker","JestWorker","Transform","formatDebugAddress","formatNodeOptions","getNodeDebugType","getParsedDebugAddress","getParsedNodeOptionsWithoutInspect","RESTARTED","Symbol","cleanupWorkers","worker","curWorker","_workerPool","_workers","_child","kill","getNextBuildDebuggerPortOffset","_","constructor","workerPath","options","enableSourceMaps","timeout","onRestart","logger","console","debuggerPortOffset","isolatedMemory","farmOptions","restartPromise","resolveRestartPromise","activeTasks","_worker","undefined","process","on","close","nodeOptions","nodeDebugType","address","port","createWorker","forkOptions","env","IS_NEXT_WORKER","NODE_OPTIONS","maxRetries","Promise","resolve","enableWorkerThreads","code","signal","error","exit","data","type","onActivity","aborted","onActivityAbort","abortActivityStreamOnLog","transform","_chunk","_encoding","callback","getStdout","pipe","getStderr","stdout","stderr","onHanging","warn","end","then","hangingTimer","clearTimeout","setTimeout","method","exposedMethods","startsWith","args","attempts","result","race","bind","Error"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/esm/server/lib/utils.js /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/esm/server/lib/utils.js
--- a/packages/next/dist/esm/server/lib/utils.js	2025-09-03 22:20:44.000000000 -0700
+++ b/packages/next/dist/esm/server/lib/utils.js	2025-09-03 22:22:13.000000000 -0700
@@ -9,45 +9,37 @@
     return process.exit(code);
 }
 const parseNodeArgs = (args)=>{
-    const { values, tokens } = parseArgs({
+    const { tokens } = parseArgs({
         args,
         strict: false,
         tokens: true
     });
+    const parsedValues = {};
     // For the `NODE_OPTIONS`, we support arguments with values without the `=`
     // sign. We need to parse them manually.
-    let orphan = null;
     for(let i = 0; i < tokens.length; i++){
-        const token = tokens[i];
-        if (token.kind === 'option-terminator') {
+        const left = tokens[i];
+        const right = tokens[i + 1];
+        if (left.kind === 'option-terminator') {
             break;
         }
-        // When we encounter an option, if it's value is undefined, we should check
-        // to see if the following tokens are positional parameters. If they are,
-        // then the option is orphaned, and we can assign it.
-        if (token.kind === 'option') {
-            orphan = typeof token.value === 'undefined' ? token : null;
+        if (left.kind === 'positional') {
             continue;
         }
-        // If the token isn't a positional one, then we can't assign it to the found
-        // orphaned option.
-        if (token.kind !== 'positional') {
-            orphan = null;
-            continue;
-        }
-        // If we don't have an orphan, then we can skip this token.
-        if (!orphan) {
-            continue;
-        }
-        // If the token is a positional one, and it has a value, so add it to the
-        // values object. If it already exists, append it with a space.
-        if (orphan.name in values && typeof values[orphan.name] === 'string') {
-            values[orphan.name] += ` ${token.value}`;
-        } else {
-            values[orphan.name] = token.value;
+        parsedValues[left.rawName] ||= [];
+        // Once we identify an option, there can be an optional value, either passed
+        // explicitly to it, `--token=value` or as the following positional token,
+        // i.e. `--token value`
+        if (left.kind === 'option') {
+            if ((right == null ? void 0 : right.kind) === 'positional') {
+                parsedValues[left.rawName].push(right.value);
+                i++;
+            } else {
+                parsedValues[left.rawName].push(left.value || true);
+            }
         }
     }
-    return values;
+    return parsedValues;
 };
 /**
  * Tokenizes the arguments string into an array of strings, supporting quoted
@@ -120,6 +112,7 @@
  *
  * @returns An object with the host and port of the debug address.
  */ export const getParsedDebugAddress = ()=>{
+    var _parsed_inspect, _parsed_inspectbrk, _parsed_inspect_brk;
     const args = getNodeOptionsArgs();
     if (args.length === 0) return {
         host: undefined,
@@ -128,7 +121,7 @@
     const parsed = parseNodeArgs(args);
     // We expect to find the debug port in one of these options. The first one
     // found will be used.
-    const address = parsed.inspect ?? parsed['inspect-brk'] ?? parsed['inspect_brk'];
+    const address = ((_parsed_inspect = parsed['--inspect']) == null ? void 0 : _parsed_inspect[0]) ?? ((_parsed_inspectbrk = parsed['--inspect-brk']) == null ? void 0 : _parsed_inspectbrk[0]) ?? ((_parsed_inspect_brk = parsed['--inspect_brk']) == null ? void 0 : _parsed_inspect_brk[0]);
     if (!address || typeof address !== 'string') {
         return {
             host: undefined,
@@ -161,16 +154,19 @@
  * @param args The arguments to be stringified.
  * @returns A string with the arguments.
  */ export function formatNodeOptions(args) {
-    return Object.entries(args).map(([key, value])=>{
-        if (value === true) {
-            return `--${key}`;
-        }
-        if (value) {
-            return `--${key}=${// Values with spaces need to be quoted. We use JSON.stringify to
-            // also escape any nested quotes.
-            value.includes(' ') && !value.startsWith('"') ? JSON.stringify(value) : value}`;
-        }
-        return null;
+    return Object.entries(args).map(([key, values])=>{
+        return values.map((value)=>{
+            if (value === true) {
+                return key;
+            }
+            if (value) {
+                // Values with spaces need to be quoted. We use JSON.stringify to
+                // also escape any nested quotes.
+                const encodedValue = value.includes(' ') && !value.startsWith('"') ? JSON.stringify(value) : value;
+                return `${key}${key.startsWith('--') ? '=' : ' '}${encodedValue}`;
+            }
+            return null;
+        }).join(' ');
     }).filter((arg)=>arg !== null).join(' ');
 }
 /**
@@ -183,9 +179,9 @@
     if (args.length === 0) return {};
     const parsed = parseNodeArgs(args);
     // Remove inspect options.
-    delete parsed.inspect;
-    delete parsed['inspect-brk'];
-    delete parsed['inspect_brk'];
+    delete parsed['--inspect'];
+    delete parsed['--inspect-brk'];
+    delete parsed['--inspect_brk'];
     return parsed;
 }
 /**
@@ -198,6 +194,10 @@
     if (Object.keys(args).length === 0) return '';
     return formatNodeOptions(args);
 }
+var PatchFlags = /*#__PURE__*/ function(PatchFlags) {
+    PatchFlags["RunderworldNodeOptions"] = "runderworld.node.options.patch";
+    return PatchFlags;
+}(PatchFlags || {});
 /**
  * Check if the value is a valid positive integer and parse it. If it's not, it will throw an error.
  *
@@ -213,14 +213,15 @@
 /**
  * Get the debug type from the `NODE_OPTIONS` environment variable.
  */ export function getNodeDebugType() {
+    var _parsed_inspect, _parsed_inspectbrk, _parsed_inspect_brk;
     const args = [
         ...process.execArgv,
         ...getNodeOptionsArgs()
     ];
     if (args.length === 0) return;
     const parsed = parseNodeArgs(args);
-    if (parsed.inspect) return 'inspect';
-    if (parsed['inspect-brk'] || parsed['inspect_brk']) return 'inspect-brk';
+    if ((_parsed_inspect = parsed['--inspect']) == null ? void 0 : _parsed_inspect.length) return 'inspect';
+    if (((_parsed_inspectbrk = parsed['--inspect-brk']) == null ? void 0 : _parsed_inspectbrk.length) || ((_parsed_inspect_brk = parsed['--inspect_brk']) == null ? void 0 : _parsed_inspect_brk.length)) return 'inspect-brk';
 }
 /**
  * Get the `max-old-space-size` value from the `NODE_OPTIONS` environment
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/esm/server/lib/utils.js.map /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/esm/server/lib/utils.js.map
--- a/packages/next/dist/esm/server/lib/utils.js.map	2025-09-03 22:20:44.000000000 -0700
+++ b/packages/next/dist/esm/server/lib/utils.js.map	2025-09-03 22:22:13.000000000 -0700
@@ -1 +1 @@
-{"version":3,"sources":["../../../src/server/lib/utils.ts"],"sourcesContent":["import { parseArgs } from 'node:util'\nimport { InvalidArgumentError } from 'next/dist/compiled/commander'\n\nexport function printAndExit(message: string, code = 1) {\n  if (code === 0) {\n    console.log(message)\n  } else {\n    console.error(message)\n  }\n\n  return process.exit(code)\n}\n\nconst parseNodeArgs = (args: string[]) => {\n  const { values, tokens } = parseArgs({ args, strict: false, tokens: true })\n\n  // For the `NODE_OPTIONS`, we support arguments with values without the `=`\n  // sign. We need to parse them manually.\n  let orphan = null\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n\n    if (token.kind === 'option-terminator') {\n      break\n    }\n\n    // When we encounter an option, if it's value is undefined, we should check\n    // to see if the following tokens are positional parameters. If they are,\n    // then the option is orphaned, and we can assign it.\n    if (token.kind === 'option') {\n      orphan = typeof token.value === 'undefined' ? token : null\n      continue\n    }\n\n    // If the token isn't a positional one, then we can't assign it to the found\n    // orphaned option.\n    if (token.kind !== 'positional') {\n      orphan = null\n      continue\n    }\n\n    // If we don't have an orphan, then we can skip this token.\n    if (!orphan) {\n      continue\n    }\n\n    // If the token is a positional one, and it has a value, so add it to the\n    // values object. If it already exists, append it with a space.\n    if (orphan.name in values && typeof values[orphan.name] === 'string') {\n      values[orphan.name] += ` ${token.value}`\n    } else {\n      values[orphan.name] = token.value\n    }\n  }\n\n  return values\n}\n\n/**\n * Tokenizes the arguments string into an array of strings, supporting quoted\n * values and escaped characters.\n * Converted from: https://github.com/nodejs/node/blob/c29d53c5cfc63c5a876084e788d70c9e87bed880/src/node_options.cc#L1401\n *\n * @param input The arguments string to be tokenized.\n * @returns An array of strings with the tokenized arguments.\n */\nexport const tokenizeArgs = (input: string): string[] => {\n  let args: string[] = []\n  let isInString = false\n  let willStartNewArg = true\n\n  for (let i = 0; i < input.length; i++) {\n    let char = input[i]\n\n    // Skip any escaped characters in strings.\n    if (char === '\\\\' && isInString) {\n      // Ensure we don't have an escape character at the end.\n      if (input.length === i + 1) {\n        throw new Error('Invalid escape character at the end.')\n      }\n\n      // Skip the next character.\n      char = input[++i]\n    }\n    // If we find a space outside of a string, we should start a new argument.\n    else if (char === ' ' && !isInString) {\n      willStartNewArg = true\n      continue\n    }\n\n    // If we find a quote, we should toggle the string flag.\n    else if (char === '\"') {\n      isInString = !isInString\n      continue\n    }\n\n    // If we're starting a new argument, we should add it to the array.\n    if (willStartNewArg) {\n      args.push(char)\n      willStartNewArg = false\n    }\n    // Otherwise, add it to the last argument.\n    else {\n      args[args.length - 1] += char\n    }\n  }\n\n  if (isInString) {\n    throw new Error('Unterminated string')\n  }\n\n  return args\n}\n\n/**\n * Get the node options from the environment variable `NODE_OPTIONS` and returns\n * them as an array of strings.\n *\n * @returns An array of strings with the node options.\n */\nconst getNodeOptionsArgs = () => {\n  if (!process.env.NODE_OPTIONS) return []\n\n  return tokenizeArgs(process.env.NODE_OPTIONS)\n}\n\n/**\n * The debug address is in the form of `[host:]port`. The host is optional.\n */\ntype DebugAddress = {\n  host: string | undefined\n  port: number\n}\n\n/**\n * Formats the debug address into a string.\n */\nexport const formatDebugAddress = ({ host, port }: DebugAddress): string => {\n  if (host) return `${host}:${port}`\n  return `${port}`\n}\n\n/**\n * Get's the debug address from the `NODE_OPTIONS` environment variable. If the\n * address is not found, it returns the default host (`undefined`) and port\n * (`9229`).\n *\n * @returns An object with the host and port of the debug address.\n */\nexport const getParsedDebugAddress = (): DebugAddress => {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return { host: undefined, port: 9229 }\n\n  const parsed = parseNodeArgs(args)\n\n  // We expect to find the debug port in one of these options. The first one\n  // found will be used.\n  const address =\n    parsed.inspect ?? parsed['inspect-brk'] ?? parsed['inspect_brk']\n\n  if (!address || typeof address !== 'string') {\n    return { host: undefined, port: 9229 }\n  }\n\n  // The address is in the form of `[host:]port`. Let's parse the address.\n  if (address.includes(':')) {\n    const [host, port] = address.split(':')\n    return { host, port: parseInt(port, 10) }\n  }\n\n  return { host: undefined, port: parseInt(address, 10) }\n}\n\n/**\n * Get the debug address from the `NODE_OPTIONS` environment variable and format\n * it into a string.\n *\n * @returns A string with the formatted debug address.\n */\nexport const getFormattedDebugAddress = () =>\n  formatDebugAddress(getParsedDebugAddress())\n\n/**\n * Stringify the arguments to be used in a command line. It will ignore any\n * argument that has a value of `undefined`.\n *\n * @param args The arguments to be stringified.\n * @returns A string with the arguments.\n */\nexport function formatNodeOptions(\n  args: Record<string, string | boolean | undefined>\n): string {\n  return Object.entries(args)\n    .map(([key, value]) => {\n      if (value === true) {\n        return `--${key}`\n      }\n\n      if (value) {\n        return `--${key}=${\n          // Values with spaces need to be quoted. We use JSON.stringify to\n          // also escape any nested quotes.\n          value.includes(' ') && !value.startsWith('\"')\n            ? JSON.stringify(value)\n            : value\n        }`\n      }\n\n      return null\n    })\n    .filter((arg) => arg !== null)\n    .join(' ')\n}\n\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and parse\n * them into an object without the inspect options.\n *\n * @returns An object with the parsed node options.\n */\nexport function getParsedNodeOptionsWithoutInspect() {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return {}\n\n  const parsed = parseNodeArgs(args)\n\n  // Remove inspect options.\n  delete parsed.inspect\n  delete parsed['inspect-brk']\n  delete parsed['inspect_brk']\n\n  return parsed\n}\n\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and format\n * them into a string without the inspect options.\n *\n * @returns A string with the formatted node options.\n */\nexport function getFormattedNodeOptionsWithoutInspect() {\n  const args = getParsedNodeOptionsWithoutInspect()\n  if (Object.keys(args).length === 0) return ''\n\n  return formatNodeOptions(args)\n}\n\n/**\n * Check if the value is a valid positive integer and parse it. If it's not, it will throw an error.\n *\n * @param value The value to be parsed.\n */\nexport function parseValidPositiveInteger(value: string): number {\n  const parsedValue = parseInt(value, 10)\n\n  if (isNaN(parsedValue) || !isFinite(parsedValue) || parsedValue < 0) {\n    throw new InvalidArgumentError(`'${value}' is not a non-negative number.`)\n  }\n  return parsedValue\n}\n\nexport const RESTART_EXIT_CODE = 77\n\nexport type NodeInspectType = 'inspect' | 'inspect-brk' | undefined\n\n/**\n * Get the debug type from the `NODE_OPTIONS` environment variable.\n */\nexport function getNodeDebugType(): NodeInspectType {\n  const args = [...process.execArgv, ...getNodeOptionsArgs()]\n  if (args.length === 0) return\n\n  const parsed = parseNodeArgs(args)\n\n  if (parsed.inspect) return 'inspect'\n  if (parsed['inspect-brk'] || parsed['inspect_brk']) return 'inspect-brk'\n}\n\n/**\n * Get the `max-old-space-size` value from the `NODE_OPTIONS` environment\n * variable.\n *\n * @returns The value of the `max-old-space-size` option as a number.\n */\nexport function getMaxOldSpaceSize() {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return\n\n  const parsed = parseNodeArgs(args)\n\n  const size = parsed['max-old-space-size'] || parsed['max_old_space_size']\n  if (!size || typeof size !== 'string') return\n\n  return parseInt(size, 10)\n}\n"],"names":["parseArgs","InvalidArgumentError","printAndExit","message","code","console","log","error","process","exit","parseNodeArgs","args","values","tokens","strict","orphan","i","length","token","kind","value","name","tokenizeArgs","input","isInString","willStartNewArg","char","Error","push","getNodeOptionsArgs","env","NODE_OPTIONS","formatDebugAddress","host","port","getParsedDebugAddress","undefined","parsed","address","inspect","includes","split","parseInt","getFormattedDebugAddress","formatNodeOptions","Object","entries","map","key","startsWith","JSON","stringify","filter","arg","join","getParsedNodeOptionsWithoutInspect","getFormattedNodeOptionsWithoutInspect","keys","parseValidPositiveInteger","parsedValue","isNaN","isFinite","RESTART_EXIT_CODE","getNodeDebugType","execArgv","getMaxOldSpaceSize","size"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
+{"version":3,"sources":["../../../src/server/lib/utils.ts"],"sourcesContent":["import { parseArgs } from 'node:util'\nimport { InvalidArgumentError } from 'next/dist/compiled/commander'\n\nexport function printAndExit(message: string, code = 1) {\n  if (code === 0) {\n    console.log(message)\n  } else {\n    console.error(message)\n  }\n\n  return process.exit(code)\n}\n\nconst parseNodeArgs = (args: string[]) => {\n  const { tokens } = parseArgs({ args, strict: false, tokens: true })\n\n  const parsedValues: { [optionName: string]: Array<string | boolean> } = {}\n\n  // For the `NODE_OPTIONS`, we support arguments with values without the `=`\n  // sign. We need to parse them manually.\n  for (let i = 0; i < tokens.length; i++) {\n    const left = tokens[i]\n    const right = tokens[i + 1]\n\n    if (left.kind === 'option-terminator') {\n      break\n    }\n\n    if (left.kind === 'positional') {\n      continue\n    }\n\n    parsedValues[left.rawName] ||= []\n\n    // Once we identify an option, there can be an optional value, either passed\n    // explicitly to it, `--token=value` or as the following positional token,\n    // i.e. `--token value`\n    if (left.kind === 'option') {\n      if (right?.kind === 'positional') {\n        parsedValues[left.rawName].push(right.value)\n        i++\n      } else {\n        parsedValues[left.rawName].push(left.value || true)\n      }\n    }\n  }\n\n  return parsedValues\n}\n\n/**\n * Tokenizes the arguments string into an array of strings, supporting quoted\n * values and escaped characters.\n * Converted from: https://github.com/nodejs/node/blob/c29d53c5cfc63c5a876084e788d70c9e87bed880/src/node_options.cc#L1401\n *\n * @param input The arguments string to be tokenized.\n * @returns An array of strings with the tokenized arguments.\n */\nexport const tokenizeArgs = (input: string): string[] => {\n  let args: string[] = []\n  let isInString = false\n  let willStartNewArg = true\n\n  for (let i = 0; i < input.length; i++) {\n    let char = input[i]\n\n    // Skip any escaped characters in strings.\n    if (char === '\\\\' && isInString) {\n      // Ensure we don't have an escape character at the end.\n      if (input.length === i + 1) {\n        throw new Error('Invalid escape character at the end.')\n      }\n\n      // Skip the next character.\n      char = input[++i]\n    }\n    // If we find a space outside of a string, we should start a new argument.\n    else if (char === ' ' && !isInString) {\n      willStartNewArg = true\n      continue\n    }\n\n    // If we find a quote, we should toggle the string flag.\n    else if (char === '\"') {\n      isInString = !isInString\n      continue\n    }\n\n    // If we're starting a new argument, we should add it to the array.\n    if (willStartNewArg) {\n      args.push(char)\n      willStartNewArg = false\n    }\n    // Otherwise, add it to the last argument.\n    else {\n      args[args.length - 1] += char\n    }\n  }\n\n  if (isInString) {\n    throw new Error('Unterminated string')\n  }\n\n  return args\n}\n\n/**\n * Get the node options from the environment variable `NODE_OPTIONS` and returns\n * them as an array of strings.\n *\n * @returns An array of strings with the node options.\n */\nconst getNodeOptionsArgs = () => {\n  if (!process.env.NODE_OPTIONS) return []\n\n  return tokenizeArgs(process.env.NODE_OPTIONS)\n}\n\n/**\n * The debug address is in the form of `[host:]port`. The host is optional.\n */\ntype DebugAddress = {\n  host: string | undefined\n  port: number\n}\n\n/**\n * Formats the debug address into a string.\n */\nexport const formatDebugAddress = ({ host, port }: DebugAddress): string => {\n  if (host) return `${host}:${port}`\n  return `${port}`\n}\n\n/**\n * Get's the debug address from the `NODE_OPTIONS` environment variable. If the\n * address is not found, it returns the default host (`undefined`) and port\n * (`9229`).\n *\n * @returns An object with the host and port of the debug address.\n */\nexport const getParsedDebugAddress = (): DebugAddress => {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return { host: undefined, port: 9229 }\n\n  const parsed = parseNodeArgs(args)\n\n  // We expect to find the debug port in one of these options. The first one\n  // found will be used.\n  const address =\n    parsed['--inspect']?.[0] ??\n    parsed['--inspect-brk']?.[0] ??\n    parsed['--inspect_brk']?.[0]\n\n  if (!address || typeof address !== 'string') {\n    return { host: undefined, port: 9229 }\n  }\n\n  // The address is in the form of `[host:]port`. Let's parse the address.\n  if (address.includes(':')) {\n    const [host, port] = address.split(':')\n    return { host, port: parseInt(port, 10) }\n  }\n\n  return { host: undefined, port: parseInt(address, 10) }\n}\n\n/**\n * Get the debug address from the `NODE_OPTIONS` environment variable and format\n * it into a string.\n *\n * @returns A string with the formatted debug address.\n */\nexport const getFormattedDebugAddress = () =>\n  formatDebugAddress(getParsedDebugAddress())\n\n/**\n * Stringify the arguments to be used in a command line. It will ignore any\n * argument that has a value of `undefined`.\n *\n * @param args The arguments to be stringified.\n * @returns A string with the arguments.\n */\nexport function formatNodeOptions(\n  args: Record<string, Array<string | boolean | undefined>>\n): string {\n  return Object.entries(args)\n    .map(([key, values]) => {\n      return values\n        .map((value) => {\n          if (value === true) {\n            return key\n          }\n\n          if (value) {\n            // Values with spaces need to be quoted. We use JSON.stringify to\n            // also escape any nested quotes.\n            const encodedValue =\n              value.includes(' ') && !value.startsWith('\"')\n                ? JSON.stringify(value)\n                : value\n\n            return `${key}${key.startsWith('--') ? '=' : ' '}${encodedValue}`\n          }\n\n          return null\n        })\n        .join(' ')\n    })\n    .filter((arg) => arg !== null)\n    .join(' ')\n}\n\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and parse\n * them into an object without the inspect options.\n *\n * @returns An object with the parsed node options.\n */\nexport function getParsedNodeOptionsWithoutInspect() {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return {}\n\n  const parsed = parseNodeArgs(args)\n\n  // Remove inspect options.\n  delete parsed['--inspect']\n  delete parsed['--inspect-brk']\n  delete parsed['--inspect_brk']\n\n  return parsed\n}\n\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and format\n * them into a string without the inspect options.\n *\n * @returns A string with the formatted node options.\n */\nexport function getFormattedNodeOptionsWithoutInspect() {\n  const args = getParsedNodeOptionsWithoutInspect()\n  if (Object.keys(args).length === 0) return ''\n\n  return formatNodeOptions(args)\n}\nenum PatchFlags {\n  RunderworldNodeOptions = 'runderworld.node.options.patch'\n}\n\n/**\n * Check if the value is a valid positive integer and parse it. If it's not, it will throw an error.\n *\n * @param value The value to be parsed.\n */\nexport function parseValidPositiveInteger(value: string): number {\n  const parsedValue = parseInt(value, 10)\n\n  if (isNaN(parsedValue) || !isFinite(parsedValue) || parsedValue < 0) {\n    throw new InvalidArgumentError(`'${value}' is not a non-negative number.`)\n  }\n  return parsedValue\n}\n\nexport const RESTART_EXIT_CODE = 77\n\nexport type NodeInspectType = 'inspect' | 'inspect-brk' | undefined\n\n/**\n * Get the debug type from the `NODE_OPTIONS` environment variable.\n */\nexport function getNodeDebugType(): NodeInspectType {\n  const args = [...process.execArgv, ...getNodeOptionsArgs()]\n  if (args.length === 0) return\n\n  const parsed = parseNodeArgs(args)\n\n  if (parsed['--inspect']?.length) return 'inspect'\n  if (parsed['--inspect-brk']?.length || parsed['--inspect_brk']?.length)\n    return 'inspect-brk'\n}\n\n/**\n * Get the `max-old-space-size` value from the `NODE_OPTIONS` environment\n * variable.\n *\n * @returns The value of the `max-old-space-size` option as a number.\n */\nexport function getMaxOldSpaceSize() {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return\n\n  const parsed = parseNodeArgs(args)\n\n  const size = parsed['max-old-space-size'] || parsed['max_old_space_size']\n  if (!size || typeof size !== 'string') return\n\n  return parseInt(size, 10)\n}\n"],"names":["parseArgs","InvalidArgumentError","printAndExit","message","code","console","log","error","process","exit","parseNodeArgs","args","tokens","strict","parsedValues","i","length","left","right","kind","rawName","push","value","tokenizeArgs","input","isInString","willStartNewArg","char","Error","getNodeOptionsArgs","env","NODE_OPTIONS","formatDebugAddress","host","port","getParsedDebugAddress","parsed","undefined","address","includes","split","parseInt","getFormattedDebugAddress","formatNodeOptions","Object","entries","map","key","values","encodedValue","startsWith","JSON","stringify","join","filter","arg","getParsedNodeOptionsWithoutInspect","getFormattedNodeOptionsWithoutInspect","keys","PatchFlags","parseValidPositiveInteger","parsedValue","isNaN","isFinite","RESTART_EXIT_CODE","getNodeDebugType","execArgv","getMaxOldSpaceSize","size"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/lib/worker.js /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/lib/worker.js
--- a/packages/next/dist/lib/worker.js	2025-09-03 22:20:46.000000000 -0700
+++ b/packages/next/dist/lib/worker.js	2025-09-03 22:22:15.000000000 -0700
@@ -53,11 +53,15 @@
                 const address = (0, _utils.getParsedDebugAddress)();
                 address.port = address.port + // current process runs on `address.port`
                 1 + debuggerPortOffset;
-                nodeOptions[nodeDebugType] = (0, _utils.formatDebugAddress)(address);
+                nodeOptions[nodeDebugType] = [
+                    (0, _utils.formatDebugAddress)(address)
+                ];
             }
         }
         if (enableSourceMaps) {
-            nodeOptions['enable-source-maps'] = true;
+            nodeOptions['enable-source-maps'] = [
+                true
+            ];
         }
         if (isolatedMemory) {
             delete nodeOptions['max-old-space-size'];
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/lib/worker.js.map /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/lib/worker.js.map
--- a/packages/next/dist/lib/worker.js.map	2025-09-03 22:20:46.000000000 -0700
+++ b/packages/next/dist/lib/worker.js.map	2025-09-03 22:22:15.000000000 -0700
@@ -1 +1 @@
-{"version":3,"sources":["../../src/lib/worker.ts"],"sourcesContent":["import type { ChildProcess } from 'child_process'\nimport { Worker as JestWorker } from 'next/dist/compiled/jest-worker'\nimport { Transform } from 'stream'\nimport {\n  formatDebugAddress,\n  formatNodeOptions,\n  getNodeDebugType,\n  getParsedDebugAddress,\n  getParsedNodeOptionsWithoutInspect,\n} from '../server/lib/utils'\n\ntype FarmOptions = NonNullable<ConstructorParameters<typeof JestWorker>[1]>\n\nconst RESTARTED = Symbol('restarted')\n\nconst cleanupWorkers = (worker: JestWorker) => {\n  for (const curWorker of ((worker as any)._workerPool?._workers || []) as {\n    _child?: ChildProcess\n  }[]) {\n    curWorker._child?.kill('SIGINT')\n  }\n}\n\nexport function getNextBuildDebuggerPortOffset(_: {\n  kind: 'export-page'\n}): number {\n  // 0: export worker\n  return 0\n}\n\nexport class Worker {\n  private _worker: JestWorker | undefined\n\n  constructor(\n    workerPath: string,\n    options: Omit<FarmOptions, 'forkOptions'> & {\n      forkOptions?:\n        | (Omit<NonNullable<FarmOptions['forkOptions']>, 'env'> & {\n            env?: Partial<NodeJS.ProcessEnv> | undefined\n          })\n        | undefined\n      /**\n       * `-1` if not inspectable\n       */\n      debuggerPortOffset: number\n      enableSourceMaps?: boolean\n      /**\n       * True if `--max-old-space-size` should not be forwarded to the worker.\n       */\n      isolatedMemory: boolean\n      timeout?: number\n      onActivity?: () => void\n      onActivityAbort?: () => void\n      onRestart?: (method: string, args: any[], attempts: number) => void\n      logger?: Pick<typeof console, 'error' | 'info' | 'warn'>\n      exposedMethods: ReadonlyArray<string>\n      enableWorkerThreads?: boolean\n    }\n  ) {\n    let {\n      enableSourceMaps,\n      timeout,\n      onRestart,\n      logger = console,\n      debuggerPortOffset,\n      isolatedMemory,\n      ...farmOptions\n    } = options\n\n    let restartPromise: Promise<typeof RESTARTED>\n    let resolveRestartPromise: (arg: typeof RESTARTED) => void\n    let activeTasks = 0\n\n    this._worker = undefined\n\n    // ensure we end workers if they weren't before exit\n    process.on('exit', () => {\n      this.close()\n    })\n\n    const nodeOptions = getParsedNodeOptionsWithoutInspect()\n\n    if (debuggerPortOffset !== -1) {\n      const nodeDebugType = getNodeDebugType()\n      if (nodeDebugType) {\n        const address = getParsedDebugAddress()\n        address.port =\n          address.port +\n          // current process runs on `address.port`\n          1 +\n          debuggerPortOffset\n        nodeOptions[nodeDebugType] = formatDebugAddress(address)\n      }\n    }\n\n    if (enableSourceMaps) {\n      nodeOptions['enable-source-maps'] = true\n    }\n\n    if (isolatedMemory) {\n      delete nodeOptions['max-old-space-size']\n      delete nodeOptions['max_old_space_size']\n    }\n\n    const createWorker = () => {\n      this._worker = new JestWorker(workerPath, {\n        ...farmOptions,\n        forkOptions: {\n          ...farmOptions.forkOptions,\n          env: {\n            ...process.env,\n            ...((farmOptions.forkOptions?.env || {}) as any),\n            IS_NEXT_WORKER: 'true',\n            NODE_OPTIONS: formatNodeOptions(nodeOptions),\n          } as any,\n        },\n        maxRetries: 0,\n      }) as JestWorker\n      restartPromise = new Promise(\n        (resolve) => (resolveRestartPromise = resolve)\n      )\n\n      /**\n       * Jest Worker has two worker types, ChildProcessWorker (uses child_process) and NodeThreadWorker (uses worker_threads)\n       * Next.js uses ChildProcessWorker by default, but it can be switched to NodeThreadWorker with an experimental flag\n       *\n       * We only want to handle ChildProcessWorker's orphan process issue, so we access the private property \"_child\":\n       * https://github.com/facebook/jest/blob/b38d7d345a81d97d1dc3b68b8458b1837fbf19be/packages/jest-worker/src/workers/ChildProcessWorker.ts\n       *\n       * But this property is not available in NodeThreadWorker, so we need to check if we are using ChildProcessWorker\n       */\n      if (!farmOptions.enableWorkerThreads) {\n        for (const worker of ((this._worker as any)._workerPool?._workers ||\n          []) as {\n          _child?: ChildProcess\n        }[]) {\n          worker._child?.on('exit', (code, signal) => {\n            if ((code || (signal && signal !== 'SIGINT')) && this._worker) {\n              logger.error(\n                `Next.js build worker exited with code: ${code} and signal: ${signal}`\n              )\n\n              // if a child process doesn't exit gracefully, we want to bubble up the exit code to the parent process\n              process.exit(code ?? 1)\n            }\n          })\n\n          // if a child process emits a particular message, we track that as activity\n          // so the parent process can keep track of progress\n          worker._child?.on('message', ([, data]: [number, unknown]) => {\n            if (\n              data &&\n              typeof data === 'object' &&\n              'type' in data &&\n              data.type === 'activity'\n            ) {\n              onActivity()\n            }\n          })\n        }\n      }\n\n      let aborted = false\n      const onActivityAbort = () => {\n        if (!aborted) {\n          options.onActivityAbort?.()\n          aborted = true\n        }\n      }\n\n      // Listen to the worker's stdout and stderr, if there's any thing logged, abort the activity first\n      const abortActivityStreamOnLog = new Transform({\n        transform(_chunk, _encoding, callback) {\n          onActivityAbort()\n          callback()\n        },\n      })\n      // Stop the activity if there's any output from the worker\n      this._worker.getStdout().pipe(abortActivityStreamOnLog)\n      this._worker.getStderr().pipe(abortActivityStreamOnLog)\n\n      // Pipe the worker's stdout and stderr to the parent process\n      this._worker.getStdout().pipe(process.stdout)\n      this._worker.getStderr().pipe(process.stderr)\n    }\n    createWorker()\n\n    const onHanging = () => {\n      const worker = this._worker\n      if (!worker) return\n      const resolve = resolveRestartPromise\n      createWorker()\n      logger.warn(\n        `Sending SIGTERM signal to static worker due to timeout${\n          timeout ? ` of ${timeout / 1000} seconds` : ''\n        }. Subsequent errors may be a result of the worker exiting.`\n      )\n      worker.end().then(() => {\n        resolve(RESTARTED)\n      })\n    }\n\n    let hangingTimer: NodeJS.Timeout | false = false\n\n    const onActivity = () => {\n      if (hangingTimer) clearTimeout(hangingTimer)\n      if (options.onActivity) options.onActivity()\n\n      hangingTimer = activeTasks > 0 && setTimeout(onHanging, timeout)\n    }\n\n    for (const method of farmOptions.exposedMethods) {\n      if (method.startsWith('_')) continue\n      ;(this as any)[method] = timeout\n        ? // eslint-disable-next-line no-loop-func\n          async (...args: any[]) => {\n            activeTasks++\n            try {\n              let attempts = 0\n              for (;;) {\n                onActivity()\n                const result = await Promise.race([\n                  (this._worker as any)[method](...args),\n                  restartPromise,\n                ])\n                if (result !== RESTARTED) return result\n                if (onRestart) onRestart(method, args, ++attempts)\n              }\n            } finally {\n              activeTasks--\n              onActivity()\n            }\n          }\n        : (this._worker as any)[method].bind(this._worker)\n    }\n  }\n\n  end(): ReturnType<JestWorker['end']> {\n    const worker = this._worker\n    if (!worker) {\n      throw new Error('Farm is ended, no more calls can be done to it')\n    }\n    cleanupWorkers(worker)\n    this._worker = undefined\n    return worker.end()\n  }\n\n  /**\n   * Quietly end the worker if it exists\n   */\n  close(): void {\n    if (this._worker) {\n      cleanupWorkers(this._worker)\n      this._worker.end()\n    }\n  }\n}\n"],"names":["Worker","getNextBuildDebuggerPortOffset","RESTARTED","Symbol","cleanupWorkers","worker","curWorker","_workerPool","_workers","_child","kill","_","constructor","workerPath","options","enableSourceMaps","timeout","onRestart","logger","console","debuggerPortOffset","isolatedMemory","farmOptions","restartPromise","resolveRestartPromise","activeTasks","_worker","undefined","process","on","close","nodeOptions","getParsedNodeOptionsWithoutInspect","nodeDebugType","getNodeDebugType","address","getParsedDebugAddress","port","formatDebugAddress","createWorker","JestWorker","forkOptions","env","IS_NEXT_WORKER","NODE_OPTIONS","formatNodeOptions","maxRetries","Promise","resolve","enableWorkerThreads","code","signal","error","exit","data","type","onActivity","aborted","onActivityAbort","abortActivityStreamOnLog","Transform","transform","_chunk","_encoding","callback","getStdout","pipe","getStderr","stdout","stderr","onHanging","warn","end","then","hangingTimer","clearTimeout","setTimeout","method","exposedMethods","startsWith","args","attempts","result","race","bind","Error"],"mappings":";;;;;;;;;;;;;;;IA8BaA,MAAM;eAANA;;IAPGC,8BAA8B;eAA9BA;;;4BAtBqB;wBACX;uBAOnB;AAIP,MAAMC,YAAYC,OAAO;AAEzB,MAAMC,iBAAiB,CAACC;QACG;IAAzB,KAAK,MAAMC,aAAc,EAAA,sBAAA,AAACD,OAAeE,WAAW,qBAA3B,oBAA6BC,QAAQ,KAAI,EAAE,CAE/D;YACHF;SAAAA,oBAAAA,UAAUG,MAAM,qBAAhBH,kBAAkBI,IAAI,CAAC;IACzB;AACF;AAEO,SAAST,+BAA+BU,CAE9C;IACC,mBAAmB;IACnB,OAAO;AACT;AAEO,MAAMX;IAGXY,YACEC,UAAkB,EAClBC,OAsBC,CACD;QACA,IAAI,EACFC,gBAAgB,EAChBC,OAAO,EACPC,SAAS,EACTC,SAASC,OAAO,EAChBC,kBAAkB,EAClBC,cAAc,EACd,GAAGC,aACJ,GAAGR;QAEJ,IAAIS;QACJ,IAAIC;QACJ,IAAIC,cAAc;QAElB,IAAI,CAACC,OAAO,GAAGC;QAEf,oDAAoD;QACpDC,QAAQC,EAAE,CAAC,QAAQ;YACjB,IAAI,CAACC,KAAK;QACZ;QAEA,MAAMC,cAAcC,IAAAA,yCAAkC;QAEtD,IAAIZ,uBAAuB,CAAC,GAAG;YAC7B,MAAMa,gBAAgBC,IAAAA,uBAAgB;YACtC,IAAID,eAAe;gBACjB,MAAME,UAAUC,IAAAA,4BAAqB;gBACrCD,QAAQE,IAAI,GACVF,QAAQE,IAAI,GACZ,yCAAyC;gBACzC,IACAjB;gBACFW,WAAW,CAACE,cAAc,GAAGK,IAAAA,yBAAkB,EAACH;YAClD;QACF;QAEA,IAAIpB,kBAAkB;YACpBgB,WAAW,CAAC,qBAAqB,GAAG;QACtC;QAEA,IAAIV,gBAAgB;YAClB,OAAOU,WAAW,CAAC,qBAAqB;YACxC,OAAOA,WAAW,CAAC,qBAAqB;QAC1C;QAEA,MAAMQ,eAAe;gBAORjB;YANX,IAAI,CAACI,OAAO,GAAG,IAAIc,kBAAU,CAAC3B,YAAY;gBACxC,GAAGS,WAAW;gBACdmB,aAAa;oBACX,GAAGnB,YAAYmB,WAAW;oBAC1BC,KAAK;wBACH,GAAGd,QAAQc,GAAG;wBACd,GAAKpB,EAAAA,2BAAAA,YAAYmB,WAAW,qBAAvBnB,yBAAyBoB,GAAG,KAAI,CAAC,CAAC;wBACvCC,gBAAgB;wBAChBC,cAAcC,IAAAA,wBAAiB,EAACd;oBAClC;gBACF;gBACAe,YAAY;YACd;YACAvB,iBAAiB,IAAIwB,QACnB,CAACC,UAAaxB,wBAAwBwB;YAGxC;;;;;;;;OAQC,GACD,IAAI,CAAC1B,YAAY2B,mBAAmB,EAAE;oBACd;gBAAtB,KAAK,MAAM5C,UAAW,EAAA,4BAAA,AAAC,IAAI,CAACqB,OAAO,CAASnB,WAAW,qBAAjC,0BAAmCC,QAAQ,KAC/D,EAAE,CAEC;wBACHH,gBAWA,2EAA2E;oBAC3E,mDAAmD;oBACnDA;qBAbAA,iBAAAA,OAAOI,MAAM,qBAAbJ,eAAewB,EAAE,CAAC,QAAQ,CAACqB,MAAMC;wBAC/B,IAAI,AAACD,CAAAA,QAASC,UAAUA,WAAW,QAAQ,KAAM,IAAI,CAACzB,OAAO,EAAE;4BAC7DR,OAAOkC,KAAK,CACV,CAAC,uCAAuC,EAAEF,KAAK,aAAa,EAAEC,QAAQ;4BAGxE,uGAAuG;4BACvGvB,QAAQyB,IAAI,CAACH,QAAQ;wBACvB;oBACF;qBAIA7C,kBAAAA,OAAOI,MAAM,qBAAbJ,gBAAewB,EAAE,CAAC,WAAW,CAAC,GAAGyB,KAAwB;wBACvD,IACEA,QACA,OAAOA,SAAS,YAChB,UAAUA,QACVA,KAAKC,IAAI,KAAK,YACd;4BACAC;wBACF;oBACF;gBACF;YACF;YAEA,IAAIC,UAAU;YACd,MAAMC,kBAAkB;gBACtB,IAAI,CAACD,SAAS;oBACZ3C,QAAQ4C,eAAe,oBAAvB5C,QAAQ4C,eAAe,MAAvB5C;oBACA2C,UAAU;gBACZ;YACF;YAEA,kGAAkG;YAClG,MAAME,2BAA2B,IAAIC,iBAAS,CAAC;gBAC7CC,WAAUC,MAAM,EAAEC,SAAS,EAAEC,QAAQ;oBACnCN;oBACAM;gBACF;YACF;YACA,0DAA0D;YAC1D,IAAI,CAACtC,OAAO,CAACuC,SAAS,GAAGC,IAAI,CAACP;YAC9B,IAAI,CAACjC,OAAO,CAACyC,SAAS,GAAGD,IAAI,CAACP;YAE9B,4DAA4D;YAC5D,IAAI,CAACjC,OAAO,CAACuC,SAAS,GAAGC,IAAI,CAACtC,QAAQwC,MAAM;YAC5C,IAAI,CAAC1C,OAAO,CAACyC,SAAS,GAAGD,IAAI,CAACtC,QAAQyC,MAAM;QAC9C;QACA9B;QAEA,MAAM+B,YAAY;YAChB,MAAMjE,SAAS,IAAI,CAACqB,OAAO;YAC3B,IAAI,CAACrB,QAAQ;YACb,MAAM2C,UAAUxB;YAChBe;YACArB,OAAOqD,IAAI,CACT,CAAC,sDAAsD,EACrDvD,UAAU,CAAC,IAAI,EAAEA,UAAU,KAAK,QAAQ,CAAC,GAAG,GAC7C,0DAA0D,CAAC;YAE9DX,OAAOmE,GAAG,GAAGC,IAAI,CAAC;gBAChBzB,QAAQ9C;YACV;QACF;QAEA,IAAIwE,eAAuC;QAE3C,MAAMlB,aAAa;YACjB,IAAIkB,cAAcC,aAAaD;YAC/B,IAAI5D,QAAQ0C,UAAU,EAAE1C,QAAQ0C,UAAU;YAE1CkB,eAAejD,cAAc,KAAKmD,WAAWN,WAAWtD;QAC1D;QAEA,KAAK,MAAM6D,UAAUvD,YAAYwD,cAAc,CAAE;YAC/C,IAAID,OAAOE,UAAU,CAAC,MAAM;YAC3B,AAAC,IAAI,AAAQ,CAACF,OAAO,GAAG7D,UAErB,OAAO,GAAGgE;gBACRvD;gBACA,IAAI;oBACF,IAAIwD,WAAW;oBACf,OAAS;wBACPzB;wBACA,MAAM0B,SAAS,MAAMnC,QAAQoC,IAAI,CAAC;4BAC/B,IAAI,CAACzD,OAAO,AAAQ,CAACmD,OAAO,IAAIG;4BACjCzD;yBACD;wBACD,IAAI2D,WAAWhF,WAAW,OAAOgF;wBACjC,IAAIjE,WAAWA,UAAU4D,QAAQG,MAAM,EAAEC;oBAC3C;gBACF,SAAU;oBACRxD;oBACA+B;gBACF;YACF,IACA,AAAC,IAAI,CAAC9B,OAAO,AAAQ,CAACmD,OAAO,CAACO,IAAI,CAAC,IAAI,CAAC1D,OAAO;QACrD;IACF;IAEA8C,MAAqC;QACnC,MAAMnE,SAAS,IAAI,CAACqB,OAAO;QAC3B,IAAI,CAACrB,QAAQ;YACX,MAAM,qBAA2D,CAA3D,IAAIgF,MAAM,mDAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAA0D;QAClE;QACAjF,eAAeC;QACf,IAAI,CAACqB,OAAO,GAAGC;QACf,OAAOtB,OAAOmE,GAAG;IACnB;IAEA;;GAEC,GACD1C,QAAc;QACZ,IAAI,IAAI,CAACJ,OAAO,EAAE;YAChBtB,eAAe,IAAI,CAACsB,OAAO;YAC3B,IAAI,CAACA,OAAO,CAAC8C,GAAG;QAClB;IACF;AACF","ignoreList":[0]}
\ No newline at end of file
+{"version":3,"sources":["../../src/lib/worker.ts"],"sourcesContent":["import type { ChildProcess } from 'child_process'\nimport { Worker as JestWorker } from 'next/dist/compiled/jest-worker'\nimport { Transform } from 'stream'\nimport {\n  formatDebugAddress,\n  formatNodeOptions,\n  getNodeDebugType,\n  getParsedDebugAddress,\n  getParsedNodeOptionsWithoutInspect,\n} from '../server/lib/utils'\n\ntype FarmOptions = NonNullable<ConstructorParameters<typeof JestWorker>[1]>\n\nconst RESTARTED = Symbol('restarted')\n\nconst cleanupWorkers = (worker: JestWorker) => {\n  for (const curWorker of ((worker as any)._workerPool?._workers || []) as {\n    _child?: ChildProcess\n  }[]) {\n    curWorker._child?.kill('SIGINT')\n  }\n}\n\nexport function getNextBuildDebuggerPortOffset(_: {\n  kind: 'export-page'\n}): number {\n  // 0: export worker\n  return 0\n}\n\nexport class Worker {\n  private _worker: JestWorker | undefined\n\n  constructor(\n    workerPath: string,\n    options: Omit<FarmOptions, 'forkOptions'> & {\n      forkOptions?:\n        | (Omit<NonNullable<FarmOptions['forkOptions']>, 'env'> & {\n            env?: Partial<NodeJS.ProcessEnv> | undefined\n          })\n        | undefined\n      /**\n       * `-1` if not inspectable\n       */\n      debuggerPortOffset: number\n      enableSourceMaps?: boolean\n      /**\n       * True if `--max-old-space-size` should not be forwarded to the worker.\n       */\n      isolatedMemory: boolean\n      timeout?: number\n      onActivity?: () => void\n      onActivityAbort?: () => void\n      onRestart?: (method: string, args: any[], attempts: number) => void\n      logger?: Pick<typeof console, 'error' | 'info' | 'warn'>\n      exposedMethods: ReadonlyArray<string>\n      enableWorkerThreads?: boolean\n    }\n  ) {\n    let {\n      enableSourceMaps,\n      timeout,\n      onRestart,\n      logger = console,\n      debuggerPortOffset,\n      isolatedMemory,\n      ...farmOptions\n    } = options\n\n    let restartPromise: Promise<typeof RESTARTED>\n    let resolveRestartPromise: (arg: typeof RESTARTED) => void\n    let activeTasks = 0\n\n    this._worker = undefined\n\n    // ensure we end workers if they weren't before exit\n    process.on('exit', () => {\n      this.close()\n    })\n\n    const nodeOptions = getParsedNodeOptionsWithoutInspect()\n\n    if (debuggerPortOffset !== -1) {\n      const nodeDebugType = getNodeDebugType()\n      if (nodeDebugType) {\n        const address = getParsedDebugAddress()\n        address.port =\n          address.port +\n          // current process runs on `address.port`\n          1 +\n          debuggerPortOffset\n        nodeOptions[nodeDebugType] = [formatDebugAddress(address)]\n      }\n    }\n\n    if (enableSourceMaps) {\n      nodeOptions['enable-source-maps'] = [true]\n    }\n\n    if (isolatedMemory) {\n      delete nodeOptions['max-old-space-size']\n      delete nodeOptions['max_old_space_size']\n    }\n\n    const createWorker = () => {\n      this._worker = new JestWorker(workerPath, {\n        ...farmOptions,\n        forkOptions: {\n          ...farmOptions.forkOptions,\n          env: {\n            ...process.env,\n            ...((farmOptions.forkOptions?.env || {}) as any),\n            IS_NEXT_WORKER: 'true',\n            NODE_OPTIONS: formatNodeOptions(nodeOptions),\n          } as any,\n        },\n        maxRetries: 0,\n      }) as JestWorker\n      restartPromise = new Promise(\n        (resolve) => (resolveRestartPromise = resolve)\n      )\n\n      /**\n       * Jest Worker has two worker types, ChildProcessWorker (uses child_process) and NodeThreadWorker (uses worker_threads)\n       * Next.js uses ChildProcessWorker by default, but it can be switched to NodeThreadWorker with an experimental flag\n       *\n       * We only want to handle ChildProcessWorker's orphan process issue, so we access the private property \"_child\":\n       * https://github.com/facebook/jest/blob/b38d7d345a81d97d1dc3b68b8458b1837fbf19be/packages/jest-worker/src/workers/ChildProcessWorker.ts\n       *\n       * But this property is not available in NodeThreadWorker, so we need to check if we are using ChildProcessWorker\n       */\n      if (!farmOptions.enableWorkerThreads) {\n        for (const worker of ((this._worker as any)._workerPool?._workers ||\n          []) as {\n          _child?: ChildProcess\n        }[]) {\n          worker._child?.on('exit', (code, signal) => {\n            if ((code || (signal && signal !== 'SIGINT')) && this._worker) {\n              logger.error(\n                `Next.js build worker exited with code: ${code} and signal: ${signal}`\n              )\n\n              // if a child process doesn't exit gracefully, we want to bubble up the exit code to the parent process\n              process.exit(code ?? 1)\n            }\n          })\n\n          // if a child process emits a particular message, we track that as activity\n          // so the parent process can keep track of progress\n          worker._child?.on('message', ([, data]: [number, unknown]) => {\n            if (\n              data &&\n              typeof data === 'object' &&\n              'type' in data &&\n              data.type === 'activity'\n            ) {\n              onActivity()\n            }\n          })\n        }\n      }\n\n      let aborted = false\n      const onActivityAbort = () => {\n        if (!aborted) {\n          options.onActivityAbort?.()\n          aborted = true\n        }\n      }\n\n      // Listen to the worker's stdout and stderr, if there's any thing logged, abort the activity first\n      const abortActivityStreamOnLog = new Transform({\n        transform(_chunk, _encoding, callback) {\n          onActivityAbort()\n          callback()\n        },\n      })\n      // Stop the activity if there's any output from the worker\n      this._worker.getStdout().pipe(abortActivityStreamOnLog)\n      this._worker.getStderr().pipe(abortActivityStreamOnLog)\n\n      // Pipe the worker's stdout and stderr to the parent process\n      this._worker.getStdout().pipe(process.stdout)\n      this._worker.getStderr().pipe(process.stderr)\n    }\n    createWorker()\n\n    const onHanging = () => {\n      const worker = this._worker\n      if (!worker) return\n      const resolve = resolveRestartPromise\n      createWorker()\n      logger.warn(\n        `Sending SIGTERM signal to static worker due to timeout${\n          timeout ? ` of ${timeout / 1000} seconds` : ''\n        }. Subsequent errors may be a result of the worker exiting.`\n      )\n      worker.end().then(() => {\n        resolve(RESTARTED)\n      })\n    }\n\n    let hangingTimer: NodeJS.Timeout | false = false\n\n    const onActivity = () => {\n      if (hangingTimer) clearTimeout(hangingTimer)\n      if (options.onActivity) options.onActivity()\n\n      hangingTimer = activeTasks > 0 && setTimeout(onHanging, timeout)\n    }\n\n    for (const method of farmOptions.exposedMethods) {\n      if (method.startsWith('_')) continue\n      ;(this as any)[method] = timeout\n        ? // eslint-disable-next-line no-loop-func\n          async (...args: any[]) => {\n            activeTasks++\n            try {\n              let attempts = 0\n              for (;;) {\n                onActivity()\n                const result = await Promise.race([\n                  (this._worker as any)[method](...args),\n                  restartPromise,\n                ])\n                if (result !== RESTARTED) return result\n                if (onRestart) onRestart(method, args, ++attempts)\n              }\n            } finally {\n              activeTasks--\n              onActivity()\n            }\n          }\n        : (this._worker as any)[method].bind(this._worker)\n    }\n  }\n\n  end(): ReturnType<JestWorker['end']> {\n    const worker = this._worker\n    if (!worker) {\n      throw new Error('Farm is ended, no more calls can be done to it')\n    }\n    cleanupWorkers(worker)\n    this._worker = undefined\n    return worker.end()\n  }\n\n  /**\n   * Quietly end the worker if it exists\n   */\n  close(): void {\n    if (this._worker) {\n      cleanupWorkers(this._worker)\n      this._worker.end()\n    }\n  }\n}\n"],"names":["Worker","getNextBuildDebuggerPortOffset","RESTARTED","Symbol","cleanupWorkers","worker","curWorker","_workerPool","_workers","_child","kill","_","constructor","workerPath","options","enableSourceMaps","timeout","onRestart","logger","console","debuggerPortOffset","isolatedMemory","farmOptions","restartPromise","resolveRestartPromise","activeTasks","_worker","undefined","process","on","close","nodeOptions","getParsedNodeOptionsWithoutInspect","nodeDebugType","getNodeDebugType","address","getParsedDebugAddress","port","formatDebugAddress","createWorker","JestWorker","forkOptions","env","IS_NEXT_WORKER","NODE_OPTIONS","formatNodeOptions","maxRetries","Promise","resolve","enableWorkerThreads","code","signal","error","exit","data","type","onActivity","aborted","onActivityAbort","abortActivityStreamOnLog","Transform","transform","_chunk","_encoding","callback","getStdout","pipe","getStderr","stdout","stderr","onHanging","warn","end","then","hangingTimer","clearTimeout","setTimeout","method","exposedMethods","startsWith","args","attempts","result","race","bind","Error"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/server/lib/utils.d.ts /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/server/lib/utils.d.ts
--- a/packages/next/dist/server/lib/utils.d.ts	2025-09-03 22:20:45.000000000 -0700
+++ b/packages/next/dist/server/lib/utils.d.ts	2025-09-03 22:22:14.000000000 -0700
@@ -41,7 +41,7 @@
  * @param args The arguments to be stringified.
  * @returns A string with the arguments.
  */
-export declare function formatNodeOptions(args: Record<string, string | boolean | undefined>): string;
+export declare function formatNodeOptions(args: Record<string, Array<string | boolean | undefined>>): string;
 /**
  * Get the node options from the `NODE_OPTIONS` environment variable and parse
  * them into an object without the inspect options.
@@ -49,7 +49,7 @@
  * @returns An object with the parsed node options.
  */
 export declare function getParsedNodeOptionsWithoutInspect(): {
-    [longOption: string]: string | boolean | undefined;
+    [optionName: string]: (string | boolean)[];
 };
 /**
  * Get the node options from the `NODE_OPTIONS` environment variable and format
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/server/lib/utils.js /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/server/lib/utils.js
--- a/packages/next/dist/server/lib/utils.js	2025-09-03 22:20:45.000000000 -0700
+++ b/packages/next/dist/server/lib/utils.js	2025-09-03 22:22:14.000000000 -0700
@@ -71,45 +71,37 @@
     return process.exit(code);
 }
 const parseNodeArgs = (args)=>{
-    const { values, tokens } = (0, _nodeutil.parseArgs)({
+    const { tokens } = (0, _nodeutil.parseArgs)({
         args,
         strict: false,
         tokens: true
     });
+    const parsedValues = {};
     // For the `NODE_OPTIONS`, we support arguments with values without the `=`
     // sign. We need to parse them manually.
-    let orphan = null;
     for(let i = 0; i < tokens.length; i++){
-        const token = tokens[i];
-        if (token.kind === 'option-terminator') {
+        const left = tokens[i];
+        const right = tokens[i + 1];
+        if (left.kind === 'option-terminator') {
             break;
         }
-        // When we encounter an option, if it's value is undefined, we should check
-        // to see if the following tokens are positional parameters. If they are,
-        // then the option is orphaned, and we can assign it.
-        if (token.kind === 'option') {
-            orphan = typeof token.value === 'undefined' ? token : null;
+        if (left.kind === 'positional') {
             continue;
         }
-        // If the token isn't a positional one, then we can't assign it to the found
-        // orphaned option.
-        if (token.kind !== 'positional') {
-            orphan = null;
-            continue;
-        }
-        // If we don't have an orphan, then we can skip this token.
-        if (!orphan) {
-            continue;
-        }
-        // If the token is a positional one, and it has a value, so add it to the
-        // values object. If it already exists, append it with a space.
-        if (orphan.name in values && typeof values[orphan.name] === 'string') {
-            values[orphan.name] += ` ${token.value}`;
-        } else {
-            values[orphan.name] = token.value;
+        parsedValues[left.rawName] ||= [];
+        // Once we identify an option, there can be an optional value, either passed
+        // explicitly to it, `--token=value` or as the following positional token,
+        // i.e. `--token value`
+        if (left.kind === 'option') {
+            if ((right == null ? void 0 : right.kind) === 'positional') {
+                parsedValues[left.rawName].push(right.value);
+                i++;
+            } else {
+                parsedValues[left.rawName].push(left.value || true);
+            }
         }
     }
-    return values;
+    return parsedValues;
 };
 const tokenizeArgs = (input)=>{
     let args = [];
@@ -167,6 +159,7 @@
     return `${port}`;
 };
 const getParsedDebugAddress = ()=>{
+    var _parsed_inspect, _parsed_inspectbrk, _parsed_inspect_brk;
     const args = getNodeOptionsArgs();
     if (args.length === 0) return {
         host: undefined,
@@ -175,7 +168,7 @@
     const parsed = parseNodeArgs(args);
     // We expect to find the debug port in one of these options. The first one
     // found will be used.
-    const address = parsed.inspect ?? parsed['inspect-brk'] ?? parsed['inspect_brk'];
+    const address = ((_parsed_inspect = parsed['--inspect']) == null ? void 0 : _parsed_inspect[0]) ?? ((_parsed_inspectbrk = parsed['--inspect-brk']) == null ? void 0 : _parsed_inspectbrk[0]) ?? ((_parsed_inspect_brk = parsed['--inspect_brk']) == null ? void 0 : _parsed_inspect_brk[0]);
     if (!address || typeof address !== 'string') {
         return {
             host: undefined,
@@ -197,16 +190,19 @@
 };
 const getFormattedDebugAddress = ()=>formatDebugAddress(getParsedDebugAddress());
 function formatNodeOptions(args) {
-    return Object.entries(args).map(([key, value])=>{
-        if (value === true) {
-            return `--${key}`;
-        }
-        if (value) {
-            return `--${key}=${// Values with spaces need to be quoted. We use JSON.stringify to
-            // also escape any nested quotes.
-            value.includes(' ') && !value.startsWith('"') ? JSON.stringify(value) : value}`;
-        }
-        return null;
+    return Object.entries(args).map(([key, values])=>{
+        return values.map((value)=>{
+            if (value === true) {
+                return key;
+            }
+            if (value) {
+                // Values with spaces need to be quoted. We use JSON.stringify to
+                // also escape any nested quotes.
+                const encodedValue = value.includes(' ') && !value.startsWith('"') ? JSON.stringify(value) : value;
+                return `${key}${key.startsWith('--') ? '=' : ' '}${encodedValue}`;
+            }
+            return null;
+        }).join(' ');
     }).filter((arg)=>arg !== null).join(' ');
 }
 function getParsedNodeOptionsWithoutInspect() {
@@ -214,9 +210,9 @@
     if (args.length === 0) return {};
     const parsed = parseNodeArgs(args);
     // Remove inspect options.
-    delete parsed.inspect;
-    delete parsed['inspect-brk'];
-    delete parsed['inspect_brk'];
+    delete parsed['--inspect'];
+    delete parsed['--inspect-brk'];
+    delete parsed['--inspect_brk'];
     return parsed;
 }
 function getFormattedNodeOptionsWithoutInspect() {
@@ -224,6 +220,10 @@
     if (Object.keys(args).length === 0) return '';
     return formatNodeOptions(args);
 }
+var PatchFlags = /*#__PURE__*/ function(PatchFlags) {
+    PatchFlags["RunderworldNodeOptions"] = "runderworld.node.options.patch";
+    return PatchFlags;
+}(PatchFlags || {});
 function parseValidPositiveInteger(value) {
     const parsedValue = parseInt(value, 10);
     if (isNaN(parsedValue) || !isFinite(parsedValue) || parsedValue < 0) {
@@ -233,14 +233,15 @@
 }
 const RESTART_EXIT_CODE = 77;
 function getNodeDebugType() {
+    var _parsed_inspect, _parsed_inspectbrk, _parsed_inspect_brk;
     const args = [
         ...process.execArgv,
         ...getNodeOptionsArgs()
     ];
     if (args.length === 0) return;
     const parsed = parseNodeArgs(args);
-    if (parsed.inspect) return 'inspect';
-    if (parsed['inspect-brk'] || parsed['inspect_brk']) return 'inspect-brk';
+    if ((_parsed_inspect = parsed['--inspect']) == null ? void 0 : _parsed_inspect.length) return 'inspect';
+    if (((_parsed_inspectbrk = parsed['--inspect-brk']) == null ? void 0 : _parsed_inspectbrk.length) || ((_parsed_inspect_brk = parsed['--inspect_brk']) == null ? void 0 : _parsed_inspect_brk.length)) return 'inspect-brk';
 }
 function getMaxOldSpaceSize() {
     const args = getNodeOptionsArgs();
diff -urN --strip-trailing-cr /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-original/server/lib/utils.js.map /Users/runderworld/Dev/gitmo-bay/runderworld/next.js-patches/.nextjs-fork/.dist-patched/server/lib/utils.js.map
--- a/packages/next/dist/server/lib/utils.js.map	2025-09-03 22:20:45.000000000 -0700
+++ b/packages/next/dist/server/lib/utils.js.map	2025-09-03 22:22:14.000000000 -0700
@@ -1 +1 @@
-{"version":3,"sources":["../../../src/server/lib/utils.ts"],"sourcesContent":["import { parseArgs } from 'node:util'\nimport { InvalidArgumentError } from 'next/dist/compiled/commander'\n\nexport function printAndExit(message: string, code = 1) {\n  if (code === 0) {\n    console.log(message)\n  } else {\n    console.error(message)\n  }\n\n  return process.exit(code)\n}\n\nconst parseNodeArgs = (args: string[]) => {\n  const { values, tokens } = parseArgs({ args, strict: false, tokens: true })\n\n  // For the `NODE_OPTIONS`, we support arguments with values without the `=`\n  // sign. We need to parse them manually.\n  let orphan = null\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n\n    if (token.kind === 'option-terminator') {\n      break\n    }\n\n    // When we encounter an option, if it's value is undefined, we should check\n    // to see if the following tokens are positional parameters. If they are,\n    // then the option is orphaned, and we can assign it.\n    if (token.kind === 'option') {\n      orphan = typeof token.value === 'undefined' ? token : null\n      continue\n    }\n\n    // If the token isn't a positional one, then we can't assign it to the found\n    // orphaned option.\n    if (token.kind !== 'positional') {\n      orphan = null\n      continue\n    }\n\n    // If we don't have an orphan, then we can skip this token.\n    if (!orphan) {\n      continue\n    }\n\n    // If the token is a positional one, and it has a value, so add it to the\n    // values object. If it already exists, append it with a space.\n    if (orphan.name in values && typeof values[orphan.name] === 'string') {\n      values[orphan.name] += ` ${token.value}`\n    } else {\n      values[orphan.name] = token.value\n    }\n  }\n\n  return values\n}\n\n/**\n * Tokenizes the arguments string into an array of strings, supporting quoted\n * values and escaped characters.\n * Converted from: https://github.com/nodejs/node/blob/c29d53c5cfc63c5a876084e788d70c9e87bed880/src/node_options.cc#L1401\n *\n * @param input The arguments string to be tokenized.\n * @returns An array of strings with the tokenized arguments.\n */\nexport const tokenizeArgs = (input: string): string[] => {\n  let args: string[] = []\n  let isInString = false\n  let willStartNewArg = true\n\n  for (let i = 0; i < input.length; i++) {\n    let char = input[i]\n\n    // Skip any escaped characters in strings.\n    if (char === '\\\\' && isInString) {\n      // Ensure we don't have an escape character at the end.\n      if (input.length === i + 1) {\n        throw new Error('Invalid escape character at the end.')\n      }\n\n      // Skip the next character.\n      char = input[++i]\n    }\n    // If we find a space outside of a string, we should start a new argument.\n    else if (char === ' ' && !isInString) {\n      willStartNewArg = true\n      continue\n    }\n\n    // If we find a quote, we should toggle the string flag.\n    else if (char === '\"') {\n      isInString = !isInString\n      continue\n    }\n\n    // If we're starting a new argument, we should add it to the array.\n    if (willStartNewArg) {\n      args.push(char)\n      willStartNewArg = false\n    }\n    // Otherwise, add it to the last argument.\n    else {\n      args[args.length - 1] += char\n    }\n  }\n\n  if (isInString) {\n    throw new Error('Unterminated string')\n  }\n\n  return args\n}\n\n/**\n * Get the node options from the environment variable `NODE_OPTIONS` and returns\n * them as an array of strings.\n *\n * @returns An array of strings with the node options.\n */\nconst getNodeOptionsArgs = () => {\n  if (!process.env.NODE_OPTIONS) return []\n\n  return tokenizeArgs(process.env.NODE_OPTIONS)\n}\n\n/**\n * The debug address is in the form of `[host:]port`. The host is optional.\n */\ntype DebugAddress = {\n  host: string | undefined\n  port: number\n}\n\n/**\n * Formats the debug address into a string.\n */\nexport const formatDebugAddress = ({ host, port }: DebugAddress): string => {\n  if (host) return `${host}:${port}`\n  return `${port}`\n}\n\n/**\n * Get's the debug address from the `NODE_OPTIONS` environment variable. If the\n * address is not found, it returns the default host (`undefined`) and port\n * (`9229`).\n *\n * @returns An object with the host and port of the debug address.\n */\nexport const getParsedDebugAddress = (): DebugAddress => {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return { host: undefined, port: 9229 }\n\n  const parsed = parseNodeArgs(args)\n\n  // We expect to find the debug port in one of these options. The first one\n  // found will be used.\n  const address =\n    parsed.inspect ?? parsed['inspect-brk'] ?? parsed['inspect_brk']\n\n  if (!address || typeof address !== 'string') {\n    return { host: undefined, port: 9229 }\n  }\n\n  // The address is in the form of `[host:]port`. Let's parse the address.\n  if (address.includes(':')) {\n    const [host, port] = address.split(':')\n    return { host, port: parseInt(port, 10) }\n  }\n\n  return { host: undefined, port: parseInt(address, 10) }\n}\n\n/**\n * Get the debug address from the `NODE_OPTIONS` environment variable and format\n * it into a string.\n *\n * @returns A string with the formatted debug address.\n */\nexport const getFormattedDebugAddress = () =>\n  formatDebugAddress(getParsedDebugAddress())\n\n/**\n * Stringify the arguments to be used in a command line. It will ignore any\n * argument that has a value of `undefined`.\n *\n * @param args The arguments to be stringified.\n * @returns A string with the arguments.\n */\nexport function formatNodeOptions(\n  args: Record<string, string | boolean | undefined>\n): string {\n  return Object.entries(args)\n    .map(([key, value]) => {\n      if (value === true) {\n        return `--${key}`\n      }\n\n      if (value) {\n        return `--${key}=${\n          // Values with spaces need to be quoted. We use JSON.stringify to\n          // also escape any nested quotes.\n          value.includes(' ') && !value.startsWith('\"')\n            ? JSON.stringify(value)\n            : value\n        }`\n      }\n\n      return null\n    })\n    .filter((arg) => arg !== null)\n    .join(' ')\n}\n\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and parse\n * them into an object without the inspect options.\n *\n * @returns An object with the parsed node options.\n */\nexport function getParsedNodeOptionsWithoutInspect() {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return {}\n\n  const parsed = parseNodeArgs(args)\n\n  // Remove inspect options.\n  delete parsed.inspect\n  delete parsed['inspect-brk']\n  delete parsed['inspect_brk']\n\n  return parsed\n}\n\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and format\n * them into a string without the inspect options.\n *\n * @returns A string with the formatted node options.\n */\nexport function getFormattedNodeOptionsWithoutInspect() {\n  const args = getParsedNodeOptionsWithoutInspect()\n  if (Object.keys(args).length === 0) return ''\n\n  return formatNodeOptions(args)\n}\n\n/**\n * Check if the value is a valid positive integer and parse it. If it's not, it will throw an error.\n *\n * @param value The value to be parsed.\n */\nexport function parseValidPositiveInteger(value: string): number {\n  const parsedValue = parseInt(value, 10)\n\n  if (isNaN(parsedValue) || !isFinite(parsedValue) || parsedValue < 0) {\n    throw new InvalidArgumentError(`'${value}' is not a non-negative number.`)\n  }\n  return parsedValue\n}\n\nexport const RESTART_EXIT_CODE = 77\n\nexport type NodeInspectType = 'inspect' | 'inspect-brk' | undefined\n\n/**\n * Get the debug type from the `NODE_OPTIONS` environment variable.\n */\nexport function getNodeDebugType(): NodeInspectType {\n  const args = [...process.execArgv, ...getNodeOptionsArgs()]\n  if (args.length === 0) return\n\n  const parsed = parseNodeArgs(args)\n\n  if (parsed.inspect) return 'inspect'\n  if (parsed['inspect-brk'] || parsed['inspect_brk']) return 'inspect-brk'\n}\n\n/**\n * Get the `max-old-space-size` value from the `NODE_OPTIONS` environment\n * variable.\n *\n * @returns The value of the `max-old-space-size` option as a number.\n */\nexport function getMaxOldSpaceSize() {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return\n\n  const parsed = parseNodeArgs(args)\n\n  const size = parsed['max-old-space-size'] || parsed['max_old_space_size']\n  if (!size || typeof size !== 'string') return\n\n  return parseInt(size, 10)\n}\n"],"names":["RESTART_EXIT_CODE","formatDebugAddress","formatNodeOptions","getFormattedDebugAddress","getFormattedNodeOptionsWithoutInspect","getMaxOldSpaceSize","getNodeDebugType","getParsedDebugAddress","getParsedNodeOptionsWithoutInspect","parseValidPositiveInteger","printAndExit","tokenizeArgs","message","code","console","log","error","process","exit","parseNodeArgs","args","values","tokens","parseArgs","strict","orphan","i","length","token","kind","value","name","input","isInString","willStartNewArg","char","Error","push","getNodeOptionsArgs","env","NODE_OPTIONS","host","port","undefined","parsed","address","inspect","includes","split","parseInt","Object","entries","map","key","startsWith","JSON","stringify","filter","arg","join","keys","parsedValue","isNaN","isFinite","InvalidArgumentError","execArgv","size"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
+{"version":3,"sources":["../../../src/server/lib/utils.ts"],"sourcesContent":["import { parseArgs } from 'node:util'\nimport { InvalidArgumentError } from 'next/dist/compiled/commander'\n\nexport function printAndExit(message: string, code = 1) {\n  if (code === 0) {\n    console.log(message)\n  } else {\n    console.error(message)\n  }\n\n  return process.exit(code)\n}\n\nconst parseNodeArgs = (args: string[]) => {\n  const { tokens } = parseArgs({ args, strict: false, tokens: true })\n\n  const parsedValues: { [optionName: string]: Array<string | boolean> } = {}\n\n  // For the `NODE_OPTIONS`, we support arguments with values without the `=`\n  // sign. We need to parse them manually.\n  for (let i = 0; i < tokens.length; i++) {\n    const left = tokens[i]\n    const right = tokens[i + 1]\n\n    if (left.kind === 'option-terminator') {\n      break\n    }\n\n    if (left.kind === 'positional') {\n      continue\n    }\n\n    parsedValues[left.rawName] ||= []\n\n    // Once we identify an option, there can be an optional value, either passed\n    // explicitly to it, `--token=value` or as the following positional token,\n    // i.e. `--token value`\n    if (left.kind === 'option') {\n      if (right?.kind === 'positional') {\n        parsedValues[left.rawName].push(right.value)\n        i++\n      } else {\n        parsedValues[left.rawName].push(left.value || true)\n      }\n    }\n  }\n\n  return parsedValues\n}\n\n/**\n * Tokenizes the arguments string into an array of strings, supporting quoted\n * values and escaped characters.\n * Converted from: https://github.com/nodejs/node/blob/c29d53c5cfc63c5a876084e788d70c9e87bed880/src/node_options.cc#L1401\n *\n * @param input The arguments string to be tokenized.\n * @returns An array of strings with the tokenized arguments.\n */\nexport const tokenizeArgs = (input: string): string[] => {\n  let args: string[] = []\n  let isInString = false\n  let willStartNewArg = true\n\n  for (let i = 0; i < input.length; i++) {\n    let char = input[i]\n\n    // Skip any escaped characters in strings.\n    if (char === '\\\\' && isInString) {\n      // Ensure we don't have an escape character at the end.\n      if (input.length === i + 1) {\n        throw new Error('Invalid escape character at the end.')\n      }\n\n      // Skip the next character.\n      char = input[++i]\n    }\n    // If we find a space outside of a string, we should start a new argument.\n    else if (char === ' ' && !isInString) {\n      willStartNewArg = true\n      continue\n    }\n\n    // If we find a quote, we should toggle the string flag.\n    else if (char === '\"') {\n      isInString = !isInString\n      continue\n    }\n\n    // If we're starting a new argument, we should add it to the array.\n    if (willStartNewArg) {\n      args.push(char)\n      willStartNewArg = false\n    }\n    // Otherwise, add it to the last argument.\n    else {\n      args[args.length - 1] += char\n    }\n  }\n\n  if (isInString) {\n    throw new Error('Unterminated string')\n  }\n\n  return args\n}\n\n/**\n * Get the node options from the environment variable `NODE_OPTIONS` and returns\n * them as an array of strings.\n *\n * @returns An array of strings with the node options.\n */\nconst getNodeOptionsArgs = () => {\n  if (!process.env.NODE_OPTIONS) return []\n\n  return tokenizeArgs(process.env.NODE_OPTIONS)\n}\n\n/**\n * The debug address is in the form of `[host:]port`. The host is optional.\n */\ntype DebugAddress = {\n  host: string | undefined\n  port: number\n}\n\n/**\n * Formats the debug address into a string.\n */\nexport const formatDebugAddress = ({ host, port }: DebugAddress): string => {\n  if (host) return `${host}:${port}`\n  return `${port}`\n}\n\n/**\n * Get's the debug address from the `NODE_OPTIONS` environment variable. If the\n * address is not found, it returns the default host (`undefined`) and port\n * (`9229`).\n *\n * @returns An object with the host and port of the debug address.\n */\nexport const getParsedDebugAddress = (): DebugAddress => {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return { host: undefined, port: 9229 }\n\n  const parsed = parseNodeArgs(args)\n\n  // We expect to find the debug port in one of these options. The first one\n  // found will be used.\n  const address =\n    parsed['--inspect']?.[0] ??\n    parsed['--inspect-brk']?.[0] ??\n    parsed['--inspect_brk']?.[0]\n\n  if (!address || typeof address !== 'string') {\n    return { host: undefined, port: 9229 }\n  }\n\n  // The address is in the form of `[host:]port`. Let's parse the address.\n  if (address.includes(':')) {\n    const [host, port] = address.split(':')\n    return { host, port: parseInt(port, 10) }\n  }\n\n  return { host: undefined, port: parseInt(address, 10) }\n}\n\n/**\n * Get the debug address from the `NODE_OPTIONS` environment variable and format\n * it into a string.\n *\n * @returns A string with the formatted debug address.\n */\nexport const getFormattedDebugAddress = () =>\n  formatDebugAddress(getParsedDebugAddress())\n\n/**\n * Stringify the arguments to be used in a command line. It will ignore any\n * argument that has a value of `undefined`.\n *\n * @param args The arguments to be stringified.\n * @returns A string with the arguments.\n */\nexport function formatNodeOptions(\n  args: Record<string, Array<string | boolean | undefined>>\n): string {\n  return Object.entries(args)\n    .map(([key, values]) => {\n      return values\n        .map((value) => {\n          if (value === true) {\n            return key\n          }\n\n          if (value) {\n            // Values with spaces need to be quoted. We use JSON.stringify to\n            // also escape any nested quotes.\n            const encodedValue =\n              value.includes(' ') && !value.startsWith('\"')\n                ? JSON.stringify(value)\n                : value\n\n            return `${key}${key.startsWith('--') ? '=' : ' '}${encodedValue}`\n          }\n\n          return null\n        })\n        .join(' ')\n    })\n    .filter((arg) => arg !== null)\n    .join(' ')\n}\n\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and parse\n * them into an object without the inspect options.\n *\n * @returns An object with the parsed node options.\n */\nexport function getParsedNodeOptionsWithoutInspect() {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return {}\n\n  const parsed = parseNodeArgs(args)\n\n  // Remove inspect options.\n  delete parsed['--inspect']\n  delete parsed['--inspect-brk']\n  delete parsed['--inspect_brk']\n\n  return parsed\n}\n\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and format\n * them into a string without the inspect options.\n *\n * @returns A string with the formatted node options.\n */\nexport function getFormattedNodeOptionsWithoutInspect() {\n  const args = getParsedNodeOptionsWithoutInspect()\n  if (Object.keys(args).length === 0) return ''\n\n  return formatNodeOptions(args)\n}\nenum PatchFlags {\n  RunderworldNodeOptions = 'runderworld.node.options.patch'\n}\n\n/**\n * Check if the value is a valid positive integer and parse it. If it's not, it will throw an error.\n *\n * @param value The value to be parsed.\n */\nexport function parseValidPositiveInteger(value: string): number {\n  const parsedValue = parseInt(value, 10)\n\n  if (isNaN(parsedValue) || !isFinite(parsedValue) || parsedValue < 0) {\n    throw new InvalidArgumentError(`'${value}' is not a non-negative number.`)\n  }\n  return parsedValue\n}\n\nexport const RESTART_EXIT_CODE = 77\n\nexport type NodeInspectType = 'inspect' | 'inspect-brk' | undefined\n\n/**\n * Get the debug type from the `NODE_OPTIONS` environment variable.\n */\nexport function getNodeDebugType(): NodeInspectType {\n  const args = [...process.execArgv, ...getNodeOptionsArgs()]\n  if (args.length === 0) return\n\n  const parsed = parseNodeArgs(args)\n\n  if (parsed['--inspect']?.length) return 'inspect'\n  if (parsed['--inspect-brk']?.length || parsed['--inspect_brk']?.length)\n    return 'inspect-brk'\n}\n\n/**\n * Get the `max-old-space-size` value from the `NODE_OPTIONS` environment\n * variable.\n *\n * @returns The value of the `max-old-space-size` option as a number.\n */\nexport function getMaxOldSpaceSize() {\n  const args = getNodeOptionsArgs()\n  if (args.length === 0) return\n\n  const parsed = parseNodeArgs(args)\n\n  const size = parsed['max-old-space-size'] || parsed['max_old_space_size']\n  if (!size || typeof size !== 'string') return\n\n  return parseInt(size, 10)\n}\n"],"names":["RESTART_EXIT_CODE","formatDebugAddress","formatNodeOptions","getFormattedDebugAddress","getFormattedNodeOptionsWithoutInspect","getMaxOldSpaceSize","getNodeDebugType","getParsedDebugAddress","getParsedNodeOptionsWithoutInspect","parseValidPositiveInteger","printAndExit","tokenizeArgs","message","code","console","log","error","process","exit","parseNodeArgs","args","tokens","parseArgs","strict","parsedValues","i","length","left","right","kind","rawName","push","value","input","isInString","willStartNewArg","char","Error","getNodeOptionsArgs","env","NODE_OPTIONS","host","port","parsed","undefined","address","includes","split","parseInt","Object","entries","map","key","values","encodedValue","startsWith","JSON","stringify","join","filter","arg","keys","PatchFlags","parsedValue","isNaN","isFinite","InvalidArgumentError","execArgv","size"],"mappings":"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","ignoreList":[0]}
\ No newline at end of file
